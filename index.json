[{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition.","date":"2023-03-24","objectID":"/htb2023/","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition. For other challenges/categories, check out my other blogs and our team’s blogs on BKISC Blog ","date":"2023-03-24","objectID":"/htb2023/:0:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Author notes Our team, BKISC finished at top 29 of this year Cyber Apocalypse 2023 - The Cursed Mission, solved 60/74 challenges, got 18175 points in total. Personally, I really enjoy playing in the competition, and I’m looking forward to other HTB CTFs in the future. For some challenges like Somewhat Linear or Analogue Signal Processing, since I collaborated with some other players from my team, the write-ups will be on our team’s blog, BKISC Blog . ","date":"2023-03-24","objectID":"/htb2023/:1:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Shattered Tablet Challenge Information Given file: Get it here! Description: Deep in an ancient tomb, you’ve discovered a stone tablet with secret information on the locations of other relics. However, while dodging a poison dart, it slipped from your hands and shattered into hundreds of pieces. Can you reassemble it and read the clues? Category: Reverse Engineering Difficulty: Very Easy Reverse Engineering category greets us with a binary. I used IDA Pro to decompile the binary. In the main function, the input is being checked through an if clause. I used angr to get the input (you can refer to this and this, too to get the hang of angr). Here is the Python script. import angr p = angr.Project('E:/Downloads/tablet') simgr = p.factory.simulation_manager(p.factory.entry_state()) simgr.explore(find=0x401359, avoid=0x401367) for i in range(3): print(simgr.found[0].posix.dumps(i)) We have to find the address of puts(“Yes! That’s right!”); and avoid the address of puts(“No… not that”);. Also, we have to increase each of the address by 0x400000 due to the fact that this binary is PIE-enabled . Flag is: HTB{br0k3n_4p4rt,n3ver_t0_b3_r3p41r3d} ","date":"2023-03-24","objectID":"/htb2023/:2:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Needle in a Haystack Challenge Information Given file: Get it here! Description: You’ve obtained an ancient alien Datasphere, containing categorized and sorted recordings of every word in the forgotten intergalactic common language. Hidden within it is the password to a tomb, but the sphere has been worn with age and the search function no longer works, only playing random recordings. You don’t have time to search through every recording - can you crack it open and extract the answer? Category: Reverse Engineering Difficulty: Very Easy We are given an another binary. Again, load the binary using IDA Pro . This time, the main algorithm of the binary is to print out a random element from the given list, and guess what, the flag is also there! Flag is: HTB{d1v1ng_1nt0_th3_d4tab4nk5} ","date":"2023-03-24","objectID":"/htb2023/:3:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"She Shells C Shells Challenge Information Given file: Get it here! Description: You’ve arrived in the Galactic Archive, sure that a critical clue is hidden here. You wait anxiously for a terminal to boot up, hiding in the shadows from the guards hunting for you. Unfortunately, it looks like you’ll need a password to get what you need without setting off the alarms… Category: Reverse Engineering Difficulty: Very Easy We get another binary, and it’s time to use IDA Pro to decompile it. Load the binary, we notice the function func_flag. Let’s check that out! fgets(s, 256, stdin); for ( i = 0; i \u003c= 0x4C; ++i ) s[i] ^= m1[i]; if ( memcmp(s, \u0026t, 0x4DuLL) ) return 0xFFFFFFFFLL; for ( j = 0; j \u003c= 0x4C; ++j ) s[j] ^= m2[j]; printf(\"Flag: %s\\n\", s); return 0LL; This is the main part of the function. Our input string s will be used to XOR with two lists, m1 and m2. We can use export data in IDA to dump out the contents of m1 and m2, as shown below (do the same for m2). We also know that after the first XOR, s needs to be equal to t (which we can get from the memory, too). Then we can reverse XOR to find s, and the algorithm looks like this. t[i] ^ m1[i] = s[i % 8] Since after the check, we continue to XOR m2 with the modified s (which should be equal to t after the memcmp), we get the algorithm to print out our flag. t[i] ^ m2[i] = flag[i] We can use this Python script to get the flag. m2 = [ 0x64, 0x1E, 0xF5, 0xE2, 0xC0, 0x97, 0x44, 0x1B, 0xF8, 0x5F, 0xF9, 0xBE, 0x18, 0x5D, 0x48, 0x8E, 0x91, 0xE4, 0xF6, 0xF1, 0x5C, 0x8D, 0x26, 0x9E, 0x2B, 0xA1, 0x02, 0xF7, 0xC6, 0xF7, 0xE4, 0xB3, 0x98, 0xFE, 0x57, 0xED, 0x4A, 0x4B, 0xD1, 0xF6, 0xA1, 0xEB, 0x09, 0xC6, 0x99, 0xF2, 0x58, 0xFA, 0xCB, 0x6F, 0x6F, 0x5E, 0x1F, 0xBE, 0x2B, 0x13, 0x8E, 0xA5, 0xA9, 0x99, 0x93, 0xAB, 0x8F, 0x70, 0x1C, 0xC0, 0xC4, 0x3E, 0xA6, 0xFE, 0x93, 0x35, 0x90, 0xC3, 0xC9, 0x10, 0xE9] t = [0x2C,0x4A,0x0B7,0x99,0x0A3,0x0E5,0x70,0x78,0x93,0x6E,0x97,0x0D9,0x47,0x6D,0x38,0x0BD,0x0FF,0x0BB,0x85,0x99,0x6F,0xE1,0x4A,0x0AB,0x74,0x0C3,0x7B,0x0A8,0x0B2,0x9F,0x0D7,0x0EC,0x0EB,0x0CD,0x63,0x0B2,0x39,0x23,0x0E1,0x84,0x92,0x96,0x09,0x0C6,0x99,0x0F2,0x58,0x0FA,0x0CB,0x6F,0x6F,0x5E,0x1F,0x0BE,0x2B,0x13,0x8E,0x0A5,0x0A9,0x99,0x93,0x0AB,0x8F,0x70,0x1C,0x0C0,0x0C4,0x3E,0x0A6,0x0FE,0x93,0x35,0x90,0x0C3,0x0C9,0x10,0x0E9] for i in range(len(t)): print(end=chr(t[i] ^ m2[i])) Flag is: HTB{cr4ck1ng_0p3n_sh3ll5_by_th3_s34_sh0r3} ","date":"2023-03-24","objectID":"/htb2023/:4:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Hunting License Challenge Information Given file: Get it here! Description: STOP! Adventurer, have you got an up to date relic hunting license? If you don’t, you’ll need to take the exam again before you’ll be allowed passage into the spacelanes! Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Reverse Engineering Difficulty: Easy We are given a binary file, together with a netcat server. By analyzing the binary file using file , we can answer some first questions. For the next question, we can use ldd license to get info about libraries of the binary. For the upcoming question, I used gdb together with its info function command to get the address of the main function. Using IDA Pro , we can answer some more questions correctly. There will be 3 passwords for us to find, the first one is too obvious, the second one is reversed, and the last one is generated using XOR with the key 19. Here is the script for the last password. data = [0x47,0x7B,0x7A,0x61,0x77,0x52,0x7D,0x77,0x55,0x7A,0x7D,0x72,0x7F,0x32,0x32,0x32] key = 19 print(\"\".join(chr(i ^ key) for i in data)) Flag is: HTB{l1c3ns3_4cquir3d-hunt1ng_t1m3!} ","date":"2023-03-24","objectID":"/htb2023/:5:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Cave System Challenge Information Given file: Get it here! Description: Deep inside a cave system, 500 feet below the surface, you find yourself stranded with supplies running low. Ahead of you sprawls a network of tunnels, branching off and looping back on themselves. You don’t have time to explore them all - you’ll need to program your cave-crawling robot to find the way out… Category: Reverse Engineering Difficulty: Easy We are given a binary once again. Using IDA Pro , for this type of challenge, we should consider using angr or z3 solver . Here I choose to use angr . Here is the Python script. import angr p = angr.Project('E:/Downloads/cave') simgr = p.factory.simulation_manager(p.factory.entry_state()) simgr.explore(find=0x401ABA, avoid=0x401AC8) for i in range(3): print(simgr.found[0].posix.dumps(i)) We have to find the address of puts(“Freedom at last!”); and avoid the address of puts(“Lost in the darkness, you’ll wander for eternity…”);. Also, we have to increase each of the address by 0x400000 due to the fact that this binary is PIE-enabled . Flag is: HTB{H0p3_u_d1dn’t_g3t_th15_by_h4nd,1t5_4_pr3tty_l0ng_fl4g!!!} ","date":"2023-03-24","objectID":"/htb2023/:6:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Alien Saboteur Challenge Information Given file: Get it here! Description: You finally manage to make it into the main computer of the vessel, it’s time to get this over with. You try to shutdown the vessel, however a couple of access codes unknown to you are needed. You try to figure them out, but the computer start speaking some weird language, it seems like gibberish… Category: Reverse Engineering Difficulty: Medium We get a binary with a text file with no format. Analyze the binary using IDA Pro , from the function “vm_create”, the text file is contained in *(v3 + 18) and being executed like a normal binary. Each instructions appear to be at every 6th index from 0. From that, I wrote an interpreter for the text file (that runs through the binary). from malduck import xor ls = ['vm_add', 'vm_addi','vm_sub','vm_subi','vm_mul','vm_muli', 'vm_div', 'vm_cmp','vm_jmp','vm_inv', 'vm_push', 'vm_pop','vm_mov','vm_nop','vm_exit', 'vm_print', 'vm_putc','vm_je','vm_jne','vm_jle', 'vm_jge', 'vm_xor','vm_store', 'vm_load','vm_input'] def disass(code): i = 0 while i \u003c len(code): try: op = code[i] opr = ls[op] if opr == 'vm_add': print(\"{:03d}: ADD [{}] \u003c- [{}] + [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_addi': print(\"{:03d}: ADDI [{}] \u003c- [{}] + {}\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_sub': print(\"{:03d}: SUB [{}] \u003c- [{}] - [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_subi': print(\"{:03d}: SUBI [{}] \u003c- [{}] - {}\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_mul': print(\"{:03d}: MUL [{}] \u003c- [{}] * [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_muli': print(\"{:03d}: MULI [{}] \u003c- [{}] * {}\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_div': print(\"{:03d}: DIV [{}] \u003c- [{}] / [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_cmp': print(\"{:03d}: CMP flag \u003c- [{}] == [{}]\".format(i, ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_jmp': print(\"{:03d}: JMP pc \u003c- pc + [{}]\".format(i, chr(ls1[i + 2]))) i += 6 elif opr == 'vm_inv': print(\"{:03d}: INV [31] \u003c- syscall({}, {})\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_push': print(\"{:03d}: PUSH [{}]\".format(i, ls1[i + 1])) i += 6 elif opr == 'vm_pop': print(\"{:03d}: POP [{}]\".format(i, ls1[i + 1])) i += 6 elif opr == 'vm_mov': print(\"{:03d}: MOV [{}] \u003c- {}\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_nop': print(\"{:03d}: NOP\".format(i)) i += 6 elif opr == 'vm_exit': print(\"{:03d}: EXIT\".format(i)) i += 6 elif opr == 'vm_print': print(\"{:03d}: PRINT [{}]\".format(i, ls1[i + 1])) i += 6 elif opr == 'vm_putc': print(\"{:03d}: PUTC {}\".format(i, ascii(chr(ls1[i + 1])))) i += 6 elif opr == 'vm_je': print(\"{:03d}: JE pc \u003c- {} if [{}] == [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_jne': print(\"{:03d}: JNE pc \u003c- {} if [{}] != [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_jle': print(\"{:03d}: JLE pc \u003c- {} if [{}] \u003c= [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_jge': print(\"{:03d}: JGE pc \u003c- {} if [{}] \u003e= [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_xor': print(\"{:03d}: XOR [{}] \u003c- [{}] ^ [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_store': print(\"{:03d}: STORE MEM[[{}]] \u003c- [{}]\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_load': print(\"{:03d}: LOAD [{}] \u003c- MEM[[{}]]\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_input': print(\"{:03d}: INPUT [{}]\".format(i, ls1[i + 1])) i += 6 else: print(\"{:03d}: UNKNOWN\".format(i)) except: print(\"{:03d}: UNKNOWN {}\".format(i, op)) break with open('./bin','rb') as f: f = f.read() ls1 = [] ls2 = [] for i in f[3:]: ls1.append(i) for i in range(714, 714 + 220*6): ls1[i] = ls1[i] ^ 69 disass(ls1) Which gives the below output. 000: PUTC '[' 006: PUTC 'M' 012: PUTC 'a' 0","date":"2023-03-24","objectID":"/htb2023/:7:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Ancient Encodings Challenge Information Given file: Get it here! Description: Your initialization sequence requires loading various programs to gain the necessary knowledge and skills for your journey. Your first task is to learn the ancient encodings used by the aliens in their communication. Category: Crypto Difficulty: Very Easy We are given a Python script and a text file. Analyze the script, we get to know how the string is being encoded, which is Base 64 encode \u003e Conversion to long from bytes \u003e Hex. To get the original string, we simply reverse the process, using CyberChef with the hex given in the text file. Flag is: HTB{1n_y0ur_j0urn3y_y0u_wi1l_se3_th15_enc0d1ngs_ev3rywher3} ","date":"2023-03-24","objectID":"/htb2023/:8:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Small StEps Challenge Information Given file: Get it here! Description: As you continue your journey, you must learn about the encryption method the aliens used to secure their communication from eavesdroppers. The engineering team has designed a challenge that emulates the exact parameters of the aliens’ encryption system, complete with instructions and a code snippet to connect to a mock alien server. Your task is to break it. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Crypto Difficulty: Very Easy We are given two Python script. The server.py is to setup a server for RSA encryption. It will output n, e, ct upon connecting to the netcat server/run the Python script locally. Since e is always set to 3, we can use Low public exponent RSA attack to recover the initial message. In general, we only have to calculate cube root of ciphertext to get the plaintext. Below is the implementation of the attack in Python. from Crypto.Util.number import long_to_bytes import gmpy2 n = 884883504927573976507811885368533220992278181011115684591381528075201937106582650631361008463165895850991665645858432026935373136174833729634068491453157 e = 3 ct = 70407336670535933819674104208890254240063781538460394662998902860952366439176467447947737680952277637330523818962104685553250402512989897886053 pt = gmpy2.iroot(ct, 3)[0] # Get cube root of ct print(long_to_bytes(pt)) Flag is: HTB{5ma1l_E-xp0n3nt} ","date":"2023-03-24","objectID":"/htb2023/:9:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Trapped Source Challenge Information Description: Intergalactic Ministry of Spies tested Pandora’s movement and intelligence abilities. She found herself locked in a room with no apparent means of escape. Her task was to unlock the door and make her way out. Can you help her in opening the door? Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Web Exploitation Difficulty: Very Easy We are given a website that looks like it requires us to input the right password on a locker to process. View page source to see if anything is given, and we can see the correct pin is 8291. Input the correct pin and we get the flag for the challenge. Flag is: HTB{V13w_50urc3_c4n_b3_u53ful!!!} ","date":"2023-03-24","objectID":"/htb2023/:10:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Drobots Challenge Information Given file: Get it here! Description: Pandora’s latest mission as part of her reconnaissance training is to infiltrate the Drobots firm that was suspected of engaging in illegal activities. Can you help pandora with this task? Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Web Exploitation Difficulty: Very Easy We are given a website and a zip file containing the website’s source. After a quick analyze on the source, I get to understand that either we have to use SQL Injection or use a specific parameter to get to the next page. Input admin for the username and \" OR 1 = 1 – - for the password, or add /home to the URL will grant you access to the next page, which turns out to also contain the flag. Flag is: HTB{p4r4m3t3r1z4t10n_1s_1mp0rt4nt!!!} ","date":"2023-03-24","objectID":"/htb2023/:11:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Initialise Connection Challenge Information Description: In order to proceed, we need to start with the basics. Start an instance, connect to it via $ nc e.g. nc 127.0.0.1 1337 and send “1” to get the flag. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Binary Exploitation/Pwnable Difficulty: Very Easy Just a sanity check challenge, do the same thing that is being stated in the description will grant you the flag. Flag is: HTB{g3t_r34dy_f0r_s0m3_pwn} ","date":"2023-03-24","objectID":"/htb2023/:12:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Questionnaire Challenge Information Given file: Get it here! Description: It’s time to learn some things about binaries and basic c. Connect to a remote server and answer some questions to get the flag. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Binary Exploitation/Pwnable Difficulty: Very Easy We are given a binary, a C file and a netcat server to answer some questions. From the netcat, we are given some informations about the binary that we will going to work with. When compiling C/C++ source code in Linux, an ELF (Executable and Linkable Format) file is created. The flags added when compiling can affect the binary in various ways, like the protections. Another thing affected can be the architecture and the way it's linked. If the system in which the challenge is compiled is x86_64 and no flag is specified, the ELF would be x86-64 / 64-bit. If it's compiled with a flag to indicate the system, it can be x86 / 32-bit binary. To reduce its size and make debugging more difficult, the binary can be stripped or not stripped. Dynamic linking: A pointer to the linked file is included in the executable, and the file contents are not included at link time. These files are used when the program is run. Static linking: The code for all the routines called by your program becomes part of the executable file. Stripped: The binary does not contain debugging information. Not Stripped: The binary contains debugging information. The most common protections in a binary are: Canary: A random value that is generated, put on the stack, and checked before that function is left again. If the canary value is not correct-has been changed or overwritten, the application will immediately stop. NX: Stands for non-executable segments, meaning we cannot write and execute code on the stack. PIE: Stands for Position Independent Executable, which randomizes the base address of the binary as it tells the loader which virtual address it should use. RelRO: Stands for Relocation Read-Only. The headers of the binary are marked as read-only. Run the 'file' command in the terminal and 'checksec' inside the debugger. The output of 'file' command: ✗ file test test: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5a83587fbda6ad7b1aeee2d59f027a882bf2a429, for GNU/Linux 3.2.0, not stripped. The output of 'checksec' command: gef➤ checksec Canary : ✘ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Partial We are able to answer some first questions using these informations. After answering these questions correctly, we are provided with more informations about the binary. Great job so far! Now it's time to see some C code and a binary file. In the pwn_questionnaire.zip there are two files: 1. test.c 2. test The 'test.c' is the source code and 'test' is the output binary. Let's start by analyzing the code. First of all, let's focus on the '#include \u003cstdio.h\u003e' line. It includes the 'stdio.h' header file to use some of the standard functions like 'printf()'. The same principle applies for the '#include \u003cstdlib.h\u003e' line, for other functions like 'system()'. Now, let's take a closer look at: void main(){ vuln(); } By default, a binary file starts executing from the 'main()' function. In this case, 'main()' only calls another function, 'vuln()'. The function 'vuln()' has 3 lines. void vuln(){ char buffer[0x20] = {0}; fprintf(stdout, \"\\nEnter payload here: \"); fgets(buffer, 0x100, stdin); } The first line declares a 0x20-byte buffer of characters and fills it with zeros. The second line calls 'fprintf()' to print a message to stdout. Finally, the third line calls 'fgets()' to read 0x100 bytes from stdin and store them to the aformentioned buffer. Then, there is a custom 'gg()' function which calls the standard 'system()' function to print the flag. This function is never called by default. void gg(){ system(\"","date":"2023-03-24","objectID":"/htb2023/:13:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Getting Started Challenge Information Given file: Get it here! Description: Get ready for the last guided challenge and your first real exploit. It’s time to show your hacking skills. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Binary Exploitation/Pwnable Difficulty: Very Easy We are given a binary, a C file and a netcat server to work with. Same with the above challenge, netcat tells us to fill in some questions. Stack frame layout | . | \u003c- Higher addresses | . | |_____________| | | \u003c- 64 bytes | Return addr | |_____________| | | \u003c- 56 bytes | RBP | |_____________| | | \u003c- 48 bytes | target | |_____________| | | \u003c- 40 bytes | alignment | |_____________| | | \u003c- 32 bytes | Buffer[31] | |_____________| | . | | . | |_____________| | | | Buffer[0] | |_____________| \u003c- Lower addresses [Addr] | [Value] -------------------+------------------- 0x00007fff1ca33230 | 0x0000000000000000 \u003c- Start of buffer 0x00007fff1ca33238 | 0x0000000000000000 0x00007fff1ca33240 | 0x0000000000000000 0x00007fff1ca33248 | 0x0000000000000000 0x00007fff1ca33250 | 0x6969696969696969 \u003c- Dummy value for alignment 0x00007fff1ca33258 | 0x00000000deadbeef \u003c- Target to change 0x00007fff1ca33260 | 0x000055cf39fcf800 \u003c- Saved rbp 0x00007fff1ca33268 | 0x00007f62c548ac87 \u003c- Saved return address 0x00007fff1ca33270 | 0x0000000000000001 0x00007fff1ca33278 | 0x00007fff1ca33348 After we insert 4 \"A\"s, (the hex representation of A is 0x41), the stack layout like this: [Addr] | [Value] -------------------+------------------- 0x00007fff1ca33230 | 0x0000000041414141 \u003c- Start of buffer 0x00007fff1ca33238 | 0x0000000000000000 0x00007fff1ca33240 | 0x0000000000000000 0x00007fff1ca33248 | 0x0000000000000000 0x00007fff1ca33250 | 0x6969696969696969 \u003c- Dummy value for alignment 0x00007fff1ca33258 | 0x00000000deadbeef \u003c- Target to change 0x00007fff1ca33260 | 0x000055cf39fcf800 \u003c- Saved rbp 0x00007fff1ca33268 | 0x00007f62c548ac87 \u003c- Saved return address 0x00007fff1ca33270 | 0x0000000000000001 0x00007fff1ca33278 | 0x00007fff1ca33348 After we insert 4 \"B\"s, (the hex representation of B is 0x42), the stack layout looks like this: [Addr] | [Value] -------------------+------------------- 0x00007fff1ca33230 | 0x4242424241414141 \u003c- Start of buffer 0x00007fff1ca33238 | 0x0000000000000000 0x00007fff1ca33240 | 0x0000000000000000 0x00007fff1ca33248 | 0x0000000000000000 0x00007fff1ca33250 | 0x6969696969696969 \u003c- Dummy value for alignment 0x00007fff1ca33258 | 0x00000000deadbeef \u003c- Target to change 0x00007fff1ca33260 | 0x000055cf39fcf800 \u003c- Saved rbp 0x00007fff1ca33268 | 0x00007f62c548ac87 \u003c- Saved return address 0x00007fff1ca33270 | 0x0000000000000001 0x00007fff1ca33278 | 0x00007fff1ca33348 From the netcat, we are provided with these informations. We can answer the question by looking at the informations given, where we have to overwrite the alignment address and the “target’s” 0xdeadbeef value. From the stack layout given above, we can see that to fully overwrite, we need at least 40 bytes input (assume that we use Linux terminal because there will be a \\x00 overwrite at the right of the “target’s” 0xdeadbeef value) which will look like this. I don’t know why it prints out [-] You failed! though… Flag is: HTB{b0f_s33m5_3z_r1ght?} ","date":"2023-03-24","objectID":"/htb2023/:14:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Plaintext Tleasure Challenge Information Given file: Get it here! Description: Threat intelligence has found that the aliens operate through a command and control server hosted on their infrastructure. Pandora managed to penetrate their defenses and have access to their internal network. Because their server uses HTTP, Pandora captured the network traffic to steal the server’s administrator credentials. Open the provided file using Wireshark, and locate the username and password of the admin. Category: Forensics Difficulty: Very Easy We are given a network pcap file. Although we can solve this challenge using Wireshark , but to keep it simple for the very first challenge, we will use strings and grep to get the flag. Here we use strings to dump out strings from the pcap file, then use pipe (|) and grep to find for strings that match the flag format - HTB{. Flag is: HTB{th3s3_4l13ns_st1ll_us3_HTTP} ","date":"2023-03-24","objectID":"/htb2023/:15:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Alien Cradle Challenge Information Given file: Get it here! Description: In an attempt for the aliens to find more information about the relic, they launched an attack targeting Pandora’s close friends and partners that may know any secret information about it. During a recent incident believed to be operated by them, Pandora located a weird PowerShell script from the event logs, otherwise called PowerShell cradle. These scripts are usually used to download and execute the next stage of the attack. However, it seems obfuscated, and Pandora cannot understand it. Can you help her deobfuscate it? Category: Forensics Difficulty: Very Easy For this challenge, we are given a Powershell Script file. In the script, the flag is being concatenated using some Powershell magic lines of code. Flag is: HTB{p0w3rsh3ll_Cr4dl3s_c4n_g3t_th3_j0b_d0n3} ","date":"2023-03-24","objectID":"/htb2023/:16:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Extraterrestrial Persistence Challenge Information Given file: Get it here! Description: There is a rumor that aliens have developed a persistence mechanism that is impossible to detect. After investigating her recently compromised Linux server, Pandora found a possible sample of this mechanism. Can you analyze it and find out how they install their persistence? Category: Forensics Difficulty: Very Easy In this challenge, we are given a shell script to look for the flag. For the sake of understanding the flow of shell scripting, the script checks whether the username is “Pandora” and the hostname is “linux_HQ”. If the check is fulfilled, it starts the process to write the base64 decoded message into the file \"/usr/lib/systemd/system/service.service\". The decoded message turned out to contain the flag for our challenge. Flag is: HTB{th3s3_4l13nS_4r3_s00000_b4s1c} ","date":"2023-03-24","objectID":"/htb2023/:17:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Relic Maps Challenge Information Given file: Get it here! Description: Pandora received an email with a link claiming to have information about the location of the relic and attached ancient city maps, but something seems off about it. Could it be rivals trying to send her off on a distraction? Or worse, could they be trying to hack her systems to get what she knows?Investigate the given attachment and figure out what’s going on and get the flag. The link is to http://relicmaps.htb:/relicmaps.one. The document is still live (relicmaps.htb should resolve to your docker instance). Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Forensics Difficulty: Medium From the link attached to this challenge, we get an Onenote file named “relicmaps.one”. Analyze the file, we get 2 suspicious links, which lead us to 2 different files, http://relicmaps.htb/uploads/soft/topsecret-maps.one and http://relicmaps.htb/get/DdAbds/window.bat . I did some analysis on the file “topsecret-maps.one”, and there are only some PNGs inside it. In the “window.bat” file, we are given a Powershell Script. You can run it directly, but I choose to deobfuscate using Python to understand its flow. dict = \"\"\" %eFlP%\"ualBOGvshk=ws\" %eFlP%\"PxzdwcSExs= /\" %eFlP%\"ndjtYQuanY=po\" %eFlP%\"cHFmSnCqnE=Wi\" %eFlP%\"CJnGNBkyYp=co\" %eFlP%\"jaXcJXQMrV=rS\" %eFlP%\"nwIWiBzpbz=:\\\" %eFlP%\"xprVJLooVF=Po\" %eFlP%\"tzMKflzfvX=0\\\" %eFlP%\"VCWZpprcdE=1.\" %eFlP%\"XzrrbwrpmM=\\v\" %eFlP%\"BFTOQBPCju=st\" %eFlP%\"WmUoySsDby=he\" %eFlP%\"tHJYExMHlP=rs\" %eFlP%\"JPfTcZlwxJ=do\" %eFlP%\"VxroDYJQKR=y \" %eFlP%\"UBndSzFkbH=py\" %eFlP%\"KXASGLJNCX=ll\" %eFlP%\"vlwWETKcZH=em\" %eFlP%\"OOOxFGwzUd=e\"\" %eFlP%\"NCtxqhhPqI=32\" %eFlP%\"GOPdPuwuLd=\\W\" %eFlP%\"XUpMhOyyHB=ex\" %eFlP%\"cIqyYRJWbQ=we\" %eFlP%\"kTEDvsZUvn=nd\" %eFlP%\"XBucLtReBQ=Sy\" %eFlP%\"JBRccySrUq=ow\" %eFlP%\"eNOycQnIZD=xe\" %eFlP%\"chXxviaBCr=we\" %eFlP%\"YcnfCLfyyS=in\" %eFlP%\"lYCdEGtlPA=.e\" %eFlP%\"pMrovuxjjq=he\" %eFlP%\"UrPeBlCopW=ll\" %eFlP%\"ujJtlzSIGW= C\" %eFlP%\"zhNAugCrcK=\"%~0.\" %eFlP%\"ZqjBENExAX=s\\\" %VhIy%\"dzPrbmmccE=cd\" %VhIy%\"xQseEVnPet= \"%~dp0\"\" %eUFw%\"wxzMwkmbmY=gDBN\" %eUFw%\"VavtsuhNIN=F'[-\" %eUFw%\"AHKCuBAkui=r = \" %eUFw%\"ARecVABHyu=uZOc\" %eUFw%\"AbZpTpKurz=6] -\" %eUFw%\"BaMYsIgnsM=$uZO\" %eUFw%\"JBUgbyTPxp=m(, \" %eUFw%\"vGOYQQYIpx=.-16\" %eUFw%\"yPzFwnsYdA= New\" %eUFw%\"zuIYfGJIhV=O.Me\" %eUFw%\"gbXeIdPSoj='[-1\" %eUFw%\"BqEMjgsfHM=]::(\" %eUFw%\"bivuMABwCB=Invo\" %eUFw%\"SJsEzuInUY=ile \" %eUFw%\"htJeDhbeDW=();$\" %eUFw%\"ZygfZJxAOd=acUA\" %eUFw%\"eDhTebXJLa=\"%~nx0.\" %eUFw%\"YlKbYsFYPy=in $\" %eUFw%\"jdKMRqipbM=e]::\" %eUFw%\"GVIREkvxRa=();$\" %eUFw%\"OckpqzbYcn=n ''\" %eUFw%\"UPfjubfNXt=Mr, \" %eUFw%\"AkaPyEXHFq=esMa\" %eUFw%\"LODxmGMGqq=flec\" %eUFw%\"hImzprlFyw=pose\" %eUFw%\"VZAbZqJHBk=1] -\" %eUFw%\"WYJXnBQBDj= [Sy\" %eUFw%\"rSVBNvbdPT=stem\" %eUFw%\"tVtxVGNpFB=vert\" %eUFw%\"tHHIjVCHeH=::De\" %eUFw%\"WvjMoIIiUn=);$b\" %eUFw%\"vmIEtsktnA=ypto\" %eUFw%\"AbMyvUGzSH=fore\" %eUFw%\"zDUDeXKPaV=..-1\" %eUFw%\"INPLAzQfUo== [S\" %eUFw%\"ArAxZuPIrp== $B\" %eUFw%\"nGqMpclaJV=ZOcm\" %eUFw%\"lfYSggLrsL=null\" %eUFw%\"eQPFkQsLmh=hy.A\" %eUFw%\"AyyrPvjwjr=;$mN\" %eUFw%\"rjhOhltPzI=Disp\" %eUFw%\"WojQSFImBz=17js\" %eUFw%\"SKEwAQBRlN=$Nlg\" %eUFw%\"KytxcYPZKt=YiLG\" %eUFw%\"RGlZIMTaRM=urit\" %eUFw%\"igJmqZApvQ=ss -\" %eUFw%\"dGSGnKbkQW=pose\" %eUFw%\"lSUnvlNyZI=tem.\" %eUFw%\"rddZbDFvhl=)))\" %eUFw%\"KHqiJghRbq=and \" %eUFw%\"WPGlloqWfh=ddin\" %eUFw%\"pLUeCEDcNj=]::C\" %eUFw%\"drymkVAnZW=);$B\" %eUFw%\"KdByPVjCnF=ring\" %eUFw%\"VnDoNvCbDL=orF'\" %eUFw%\"GapFScCcpe=ke($\" %eUFw%\"iVrCyJhMiJ=fc6t\" %eUFw%\"oMsMdPYmPd=ert]\" %eUFw%\"odWdfvJnBE=Lk =\" %eUFw%\"ekEoGMuERC=yste\" %eUFw%\"QMmDXFyyag=Syst\" %eUFw%\"cYinxarhDL=lit(\" %eUFw%\"bIgeRgvTeJ=ap.T\" %eUFw%\"acXjUrxrpX=raph\" %eUFw%\"SCbDgQuqTU=ay()\" %eUFw%\"YYKSCuCbgJ=New-\" %eUFw%\"YnGvhgYxvb=cm =\" %eUFw%\"vnHosfjdeN=;$Pt\" %eUFw%\"LIQYgFxctD=d;$B\" %eUFw%\"olHsTHINJO=[Env\" %eUFw%\"WQqetkePWs=NVPb\" %eUFw%\"AGOCIKFMEK=::('\" %eUFw%\"QbKdEZdxpx=uGcO\" %eUFw%\"RWcegafVtf=daeR\" %eUFw%\"ESpdErsKEO=pher\" %eUFw%\"kJjQuXIjOT=.Con\" %eUFw%\"dbDMRBPrxg=uGcO\" %eUFw%\"mBIWiJN","date":"2023-03-24","objectID":"/htb2023/:18:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Persistence Challenge Information Description: Thousands of years ago, sending a GET request to /flag would grant immense power and wisdom. Now it’s broken and usually returns random data, but keep trying, and you might get lucky… Legends say it works once every 1000 tries. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Miscellaneous Difficulty: Very Easy We are given a website to work with. Initially, connection to the website would result in “404 Not Found”. I then went to read the descriptions, and from it, I got to know that we should send at least 1000 GET requests to /flag to maybe get the flag. I used this below Python script to automate the task. import requests url = \"http://64.227.41.83:30380/flag\" for i in range(10000): response = requests.get(url) content = response.content if b'HTB{' in content: print(content) break After a short wait, we got the flag. Flag is: HTB{y0u_h4v3_p0w3rfuL_sCr1pt1ng_ab1lit13S!} ","date":"2023-03-24","objectID":"/htb2023/:19:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Restricted Challenge Information Given file: Get it here! Description: You ’re still trying to collect information for your research on the alien relic. Scientists contained the memories of ancient egyptian mummies into small chips, where they could store and replay them at will. Many of these mummies were part of the battle against the aliens and you suspect their memories may reveal hints to the location of the relic and the underground vessels. You managed to get your hands on one of these chips but after you connected to it, any attempt to access its internal data proved futile. The software containing all these memories seems to be running on a restricted environment which limits your access. Can you find a way to escape the restricted environment ? Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Miscellaneous Difficulty: Easy We are provided with a server and it’s source. From the source, we know that it is a SSH server. One thing particular about this server is that, if the username is restricted, we will not need to provide a password to authenticate, but the user will be in restricted shell mode. What is restricted shell? If Bash is started with the name rbash, or the –restricted or -r option is supplied at invocation, the shell becomes restricted. A restricted shell is used to set up an environment more controlled than the standard shell. A restricted shell behaves identically to bash with the exception that some commands are disallowed or not performed. For instances, changing directories with the cd builtin is prohibited in restricted shell. To cope with this, we can use a trick called SSH self loop-back, which means we initiate a SSH connection inside a SSH, since restricted shell doesn’t prevent us from using SSH commands. First, we connect to the SSH server using the username restricted. From the source, we also know that the exposed port is 1337. Then, we can use SSH self loop-back to have the permission to use cat, since we also know that flag.txt is changed to flag_* (with * represents some random bytes) and lies in plainsight. Flag is: HTB{r35tr1ct10n5_4r3_p0w3r1355} ","date":"2023-03-24","objectID":"/htb2023/:20:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"An in-depth writeup on idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"An in-depth writeup on idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who. ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:0:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"Introduction Challenge Information Given image: Get it here! Description: I feel the killer might be dangerous so I have some info to give you but I don’t want to disclose my email just like that. So find my review from the image below and send me an email asking for info. Be creative with the signature so I know its you. It is time to find Who is the killer. Category: OSINT ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:1:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"Finding the location From the given image, I managed to have found the location on Google Maps at 41.154248, -8.682320. Then in the comment section of the location, I got the mentioned secret email, labeled noodlesareramhackers@gmail.com . ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:2:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"Getting further informations I then sent an email to the email above, and got the next instructions. From: Ramo HackerNoodles (noodlesareramhackers@gmail.com) So… I got some stuff to tell you. I think the killer is probably watching us. The killer used a weird weapon as you have found out. Look, the info I have is that weirdly enough the university page of Heather tweeted something that might lead you to the killer. They deleted it though. Luckily these days you can just walk back in time! Ah, the tweet was 1612383535549059076. When you have the info look in github! Good Luck! ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:3:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"Finding the deleted tweet In the first challenge of the Osint Crime Confusion set (W is for Where), I found the instagram of a person named Heather James . Then from this person’s informations, I found the twitter account of University of Dutch ThE of Topics in Science . I then immediately knew we have to bring the account to the Wayback Machine to gain access to the deleted tweet. The email did mention about the tweet’s id (1612383535549059076), so we can paste the below URL into the Wayback Machine. URL https://twitter.com/UThE_TS/status/1612383535549059076 We successfully gained access to the deleted tweet! ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:4:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"Exploring the killer’s GitHub From the email, we also know that we should continue searching in GitHub. Frankly enough, when I tried to search for “potatoes eating camels” in GitHub, this showed up: The descriptions imply that the person is “still improving wiki”. We then head into the wiki of this repository to find out the end of our journey. Concatenate the first letters of the last 7 sentences of the poem, we have our flag for the challenge: idek{JULIANA_APOSIDM723489}. ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:5:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"Conclusion A good OSINT challenge overall, consist of several general skills in the field of OSINT, such as using Wayback Machine or finding locations on Google Maps. ","date":"2023-01-15","objectID":"/idekctf2022-osintcrime3/:6:0","tags":["osint","idek","english"],"title":"idekCTF 2022 - Osint/Osint Crime Confusion 3: W as in Who","uri":"/idekctf2022-osintcrime3/"},{"categories":["Writeups"],"content":"An in-depth writeup on ISITDTU CTF 2022 Finals - Slow","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"An in-depth writeup on ISITDTU CTF 2022 Finals - Slow. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:0:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Introduction Challenge Information Given binary: Get it here! Description: If you can make the program runs faster, you’ll get the flag! Category: Reverse Engineering ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:1:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Static Analysis The challenge provides us with a single binary, named slow.exe. By using IDA Pro or Ghidra or any other kinds of decompiler, we will get the decompiled code. Analyze the main function, we claim that the program initiates an array whose size is 45, then modifies it through some more functions, as shown below. int __cdecl main(int argc, const char **argv, const char **envp) { void *Block; // [esp+4h] [ebp-BCh] int v5[45]; // [esp+8h] [ebp-B8h] BYREF v5[0] = 10; v5[1] = -3; ... snip v5[43] = 14; v5[44] = 16; Block = (void *)sub_401AC0(v5, 38, 0); sub_4013B0(Block); sub_401B40(Block); return 0; } The function sub_401AC0(v5, 38, 0) allocates dynamic memory using malloc based on v5 then assigns it into variable Block. That variable is then being passed into function sub_4013B0(Block), which will produce our flag once we have fixed it. int __cdecl sub_4013B0(_DWORD *a1) { int result; // eax int v2; // eax int v3; // [esp+4h] [ebp-64h] ... snip int v37; // [esp+64h] [ebp-4h] int v38; // [esp+64h] [ebp-4h] while ( 1 ) { v6 = *(_DWORD *)(a1[1] + 4 * a1[3]++); result = v6 - 1; switch ( v6 ) { case 1: v22 = *(_DWORD *)(a1[2] + 4 * a1[4]--); v26 = *(_DWORD *)(a1[2] + 4 * a1[4]--); v2 = sub_401110(v26, v22); v16 = a1[4] + 1; a1[4] = v16; *(_DWORD *)(a1[2] + 4 * v16) = v2; break; case 2: ... snip case 4: ... snip case 5: ... snip case 6: ... snip case 7: ... snip case 8: ... snip case 9: ... snip case 10: ... snip case 11: ... snip case 12: ... snip case 13: ... snip case 14: v38 = *(_DWORD *)(a1[2] + 4 * a1[4]--); sub_401040(\"RESULT: %d\\n\", v38); sub_401260(v38); break; case 15: ... snip case 16: ... snip case 17: ... snip case 18: ... snip default: continue; } } } Why didn't I snip case 1 and case 14 in the above pseudocode? It is easy to observe that only these two cases involve calling other functions. To be more precise, if the program reaches case 1, the function sub_401110(v26, v22) will be called, and on the other hand, if the program reaches case 14, the function sub_401260(v38) will be called. We will talk more about these two functions in the next parts of this blog. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:2:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Reaching case 14 As stated earlier, the function sub_401260(v38) will be called if the program reaches case 14, which will be the last part of our code flow. int __cdecl sub_401260(char a1) { char v2[256]; // [esp+10h] [ebp-224h] BYREF char Buffer; // [esp+110h] [ebp-124h] BYREF _BYTE v4[3]; // [esp+111h] [ebp-123h] BYREF char v5[32]; // [esp+210h] [ebp-24h] BYREF qmemcpy(v5, \"Áõ\", 2); v5[2] = -77; v5[3] = 26; ... snip v5[28] = -66; v5[29] = 63; memset(v2, 0, sizeof(v2)); sub_401D50(\u0026Buffer, \"%d\", 55 * a1); sub_401160(v5, v2, 30, \u0026Buffer, \u0026v4[strlen(\u0026Buffer)] - v4); return sub_401040(\"flag is: %s\", (char)v2); } The function receives our modified variable Block, then uses it to produce our flag. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:3:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Reaching case 1 Here is where things get interesting. Take a look at the function sub_401110(v26, v22), we can conclude that this is why our program runs slowly. The fact that it makes our program sleeps plus it is possibly called many times throughout the process makes our executable runs without any output for a very long time. int __cdecl sub_401110(int a1, int a2) { int v3; // [esp+0h] [ebp-4h] v3 = sub_4010F0(0); Sleep(1000 * a1); Sleep(1000 * a2); return sub_4010F0(0) - v3; } About the intended algorithm flow The algorithm here is very simple, however this is author’s idea to let the program sleeps for a total of (a1 + a2) seconds each time this function is called. The intended result of this function is to return a1 + a2. We will have to patch the binary to get our flag. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:4:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Patch the binary So we know what makes our program runs slowly, it is time to fix that. Below is the decompiled assembly code of that part. mov ecx, [ebp+arg_0] mov edx, [ecx+10h] sub edx, 1 mov eax, [ebp+arg_0] mov [eax+10h], edx mov ecx, [ebp+var_10] push ecx mov edx, [ebp+var_C] push edx call sub_401110 add esp, 8 mov [ebp+var_58], eax mov eax, [ebp+arg_0] Instead of calling sub_401110, we should patch the program to directly calculates ecx + edx then assigns it into eax. We find out that the opcode of call sub_401110 is E8 77 FC FF FF. View instructions opcode in IDA Pro Using IDA Pro integrated settings, which can be found at Options \u003e Generals \u003e Number of Opcode bytes (non-graph) set to a large enough number, we can view each instruction’s opcode. With pwntools library, we also find out the opcode for add ecx, edx and move eax, ecx is 01 D1 and 89 C8 using this script written in Python below. from pwn import * context.arch = 'amd64' print(asm('add ecx, edx')) print(asm('mov eax, ecx')) It is now time to patch the binary. Use any hex editor of your choice to patch the binary, here I use IDA Pro’s integrated hex view to patch the binary. Our goal Change E8 77 FC FF FF to 01 D1 89 C8 90 using any hex editor of your choice (here 90 corresponds to the NOP instruction). ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:5:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Result After patching the binary, run it again to get our flag. fazect@LAPTOP-CQA118DI:/mnt/d/Downloads$ ./slow.exe RESULT: 75025 flag is: Pr4ct1c3_VMc0d3_w1th_F1b0n4cc1 Wrap the flag with ISITDTU{}, we have our flag for the challenge: ISITDTU{Pr4ct1c3_VMc0d3_w1th_F1b0n4cc1}. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:6:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Some Background Informations I am FazeCT, a Reverser from team BKISC , HCMC University of Technology. I have been studying in Computer Science, HCMC University of Technology since October 2021. Started playing CTFs since July 2022, currently I am focusly learning in the Reverse Engineering (RE) field of CTF. I am also looking forward to learn more about Blockchain in the future. ","date":"0001-01-01","objectID":"/aboutme/:1:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Noticeable Achievements Qualified for ISITDTU CTF 2022 Finals in Da Nang, Vietnam. Qualified for Hacktheon Sejong Finals in Sejong, Korea. Ranked 57th in 2022 ACM-ICPC Asia HoChiMinh City Regional Contest ","date":"0001-01-01","objectID":"/aboutme/:2:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Contact Me You can contact me via Email or Github . ","date":"0001-01-01","objectID":"/aboutme/:3:0","tags":null,"title":"About Me","uri":"/aboutme/"}]