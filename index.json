[{"categories":["Writeups"],"content":"Solutions to ALL reverse engineering challenges in the event.","date":"2023-07-20","objectID":"/amateursctf2023-rev/","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"Solutions to ALL reverse engineering challenges in the event. ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:0:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"Overview Last weekend, I had the opportunity to participate in the event with my team, NEW JEANS FC (aka thehackerscrew), where I did all the reverse engineering challenges! I want to give a big shoutout to the authors, and especially flocto, for creating such cool reverse challenges! All of the challenges’ binaries can be found here: Click me! ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:1:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"volcano Challenge Information Given file: volcano Description: Inspired by recent “traumatic” events. We are given a binary file named volcano. Load it in your favorite tool (mine was IDA) and get ready for our first task! The program prompts user for 3 numeral inputs. First input is checked using the below function: _BOOL8 __fastcall check_first(unsigned __int64 input) { if ( (input \u0026 1) != 0 ) return 0LL; if ( input % 3 != 2 ) return 0LL; if ( input % 5 != 1 ) return 0LL; if ( input % 7 == 3 ) return input % 0x6D == 55; return 0LL; } By using some math (or even trial and error), we can easily point out that there are a lot of solutions to this in the form of 18476 + 22890 * n. Second input is checked using the below function: _BOOL8 __fastcall check_second(unsigned __int64 input) { unsigned __int64 v2; // [rsp+8h] [rbp-10h] v2 = 0LL; while ( input ) { v2 += input \u0026 1; input \u003e\u003e= 1; } return v2 \u003e 0x10 \u0026\u0026 v2 \u003c= 0x1A; } This function maybe harder for analyzing than the first, but it is just counting number of set bits (1 bits) of the input. Third input is used in several functions to compare first two inputs. And to solve this challenge, it is really simple to just write a script to find a 64-bit number that satisfies both constraints, and I used this script below to get it. for i in range(18476, 2 ** 64, 22890): k = bin(i).count('1') if 0x10 \u003c k \u003c= 0x14: print(i) From the list of results, I chose 26264942966 to send for the first two inputs, and randomly chose 1337 for the third input. Flag is: amateursCTF{yep_th0se_l00k_th3_s4me_to_m3!_:clueless:} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:2:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"rusteze Challenge Information Given file: rusteze Description: Get rid of all your Rust rust with this brand new Rust-eze™ de-ruster. Flag is amateursCTF{[a-zA-Z0-9_]+}. We are provided a binary named rusteze. Again, load it using a decompiler of your choice and seek for the main function. The program wants us to input in a string with length 38. Then it initiates 2 arrays also of size 38 each (I will call them a and b). The input is checked like this: assert rol(input[i] ^ a[i], 2) == b[i] Knowing that, I dumped out 2 arrays and used this script to solve for the input. def solve(a, b): k = bin(b)[2:].rjust(8, '0') k = k[-2:] + k[:-2] print(end=chr(a ^ int(k, 2))) arr_1 = [0] * 100 arr_2 = [0] * 100 arr_1[0] = 39 arr_1[1] = -105 arr_1[2] = 87 arr_1[4] = -87 arr_1[5] = 117 arr_1[6] = 102 arr_1[7] = 62 arr_1[8] = 27 arr_1[9] = 99 arr_1[10] = -29 arr_1[11] = -96 arr_1[12] = 5 arr_1[13] = 115 arr_1[14] = 89 arr_1[15] = -5 arr_1[16] = 10 arr_1[17] = 67 arr_1[18] = -113 arr_1[19] = -32 arr_1[20] = -70 arr_1[21] = -64 arr_1[22] = 84 arr_1[23] = -103 arr_1[24] = 6 arr_1[25] = -65 arr_1[26] = -97 arr_1[27] = 47 arr_1[28] = -60 arr_1[29] = -86 arr_1[30] = -90 arr_1[31] = 116 arr_1[32] = 30 arr_1[33] = -35 arr_1[34] = -105 arr_1[35] = 34 arr_1[36] = -19 arr_1[37] = -59 arr_2[0] = 25 arr_2[1] = -21 arr_2[2] = -40 arr_2[3] = ord('V') arr_2[4] = ord('3') arr_2[3 + 3] = 80 arr_2[4 + 3] = 53 arr_2[5 + 3] = 97 arr_2[6 + 3] = -36 arr_2[7 + 3] = -106 arr_2[8 + 3] = 111 arr_2[9 + 3] = -75 arr_2[10 + 3] = 13 arr_2[11 + 3] = -92 arr_2[12 + 3] = 122 arr_2[13 + 3] = 85 arr_2[14 + 3] = -24 arr_2[15 + 3] = -2 arr_2[16 + 3] = 86 arr_2[17 + 3] = -105 arr_2[18 + 3] = -34 arr_2[19 + 3] = -99 arr_2[20 + 3] = -81 arr_2[21 + 3] = -44 arr_2[22 + 3] = 71 arr_2[23 + 3] = -81 arr_2[24 + 3] = -63 arr_2[25 + 3] = -62 arr_2[26 + 3] = 106 arr_2[27 + 3] = 90 arr_2[28 + 3] = -84 arr_2[29 + 3] = -79 arr_2[30 + 3] = -94 arr_2[31 + 3] = -118 arr_2[32 + 3] = 89 arr_2[33 + 3] = 82 arr_2[34 + 3] = -30 for i in range(38): solve(arr_1[i] \u0026 0xFF, arr_2[i] \u0026 0xFF) # amaeursCTF{h0pe_y0u_w3r3nt_t00_ru5ty} There was something wrong with the first part of the flag but it doesn’t matter, and I was also lazy to recheck it. Flag is: amateursCTF{h0pe_y0u_w3r3nt_t00_ru5ty} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:3:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"trick question Challenge Information Given file: trick-question.pyc Description: Which one do you hate more: decompiling pycs or reading Python bytecode disassembly? Just kidding that’s a trick question. Run with Python version 3.10. Flag is amateursCTF{[a-zA-Z0-9_]+}. For this challenge, we are given a python bytecode file. I used pycdc as always to decompile the .pyc file and got this python source. # Source Generated with Decompyle++ # File: trick-question.pyc (Python 3.10) b64decode = lambda x: id.__self__.__dict__['exec'](id.__self__.__dict__['__import__']('base64').b64decode(x)) r = [ 0, 0, 1, [...] 0, 0, 0] x = [ 'gIHByaW50KCJJbmNvcnJlY3QuIik=', 'gcHJpbnQoIkNvcnJlY3QhIikKZWxzZToKIC', 'CIgogOpkiIgozZhxmZgUGa0BiclRnbFJCK0VHculGKrNWZoNGImlmCp0HZpBiOnQWansHIsUGZvNGKps2Ylh2YoUGc5RHI9', [...] 'ya1x4MDNyXHgwZXRceD', 'xXHg4NVx4MDJceDE5XHgwMGRceD', 'Y2hlY2sgPSBsYW1iZGE6Tm9uZQpjb2RlID0gdHlwZShjaGVjay5fX2NvZGVfXykoMSwgMCwgMCwgNiwgNSwgNjcsIGInfFx4MDBkXHgwMGRceD'] for i in range(len(r)): if r[i]: x[i] = x[i][::-1] b64decode('A'.join(x[::-1])) Next thing I did was taking the result of this 'A'.join(x[::-1]) and threw it in an online decoder so that we can get raw code instead of running it (a good online decoder can be found here: CyberChef ). I got this as a result: check = lambda:None code = type(check.__code__)(1, 0, 0, 6, 5, 67, b'|\\x00d\\x00d\\x01\\x85\\x02\\x19\\x00d\\x02k\\x03r\\x0et\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00|\\x00d\\x04\\x19\\x00d\\x05k\\x03r\\x1at\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00|\\x00d\\x01d\\x04\\x85\\x02\\x19\\x00}\\x00t\\x00j\\x01j\\x02d\\x06\\x19\\x00|\\x00\\x83\\x01d\\x07k\\x03r0t\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00g\\x00}\\x01t\\x00j\\x01j\\x02d\\x08\\x19\\x00|\\x00\\x83\\x01D\\x00]\\r\\\\\\x02}\\x02}\\x03|\\x03d\\tk\\x02rG|\\x01\\xa0\\x03|\\x02\\xa1\\x01\\x01\\x00q:|\\x01g\\x00d\\n\\xa2\\x01k\\x03rTt\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00|\\x00\\xa0\\x04\\xa1\\x00\\xa0\\x05d\\x0b\\xa1\\x01}\\x00|\\x00d\\x0c\\x19\\x00d\\x00d\\x00d\\x04\\x85\\x03\\x19\\x00d\\rk\\x03rlt\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00|\\x00d\\x0e\\x19\\x00d\\x0c\\x19\\x00|\\x00d\\x0e\\x19\\x00d\\x0e\\x19\\x00\\x17\\x00|\\x00d\\x0e\\x19\\x00d\\x0f\\x19\\x00\\x18\\x00|\\x00d\\x0e\\x19\\x00d\\x0e\\x19\\x00|\\x00d\\x0e\\x19\\x00d\\x0f\\x19\\x00\\x17\\x00|\\x00d\\x0e\\x19\\x00d\\x0c\\x19\\x00\\x18\\x00|\\x00d\\x0e\\x19\\x00d\\x0f\\x19\\x00|\\x00d\\x0e\\x19\\x00d\\x0c\\x19\\x00\\x17\\x00|\\x00d\\x0e\\x19\\x00d\\x0e\\x19\\x00\\x18\\x00f\\x03d\\x10k\\x03r\\xa9t\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00t\\x00j\\x01j\\x02d\\x11\\x19\\x00d\\x12\\x83\\x01\\xa0\\x06|\\x00d\\x0f\\x19\\x00\\xa1\\x01\\xa0\\x07\\xa1\\x00d\\x13k\\x03r\\xc0t\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00t\\x00j\\x01j\\x02d\\x11\\x19\\x00d\\x14\\x83\\x01}\\x04|\\x04\\xa0\\x08|\\x00d\\x0f\\x19\\x00\\xa1\\x01\\x01\\x00t\\x00j\\x01j\\x02d\\x15\\x19\\x00|\\x00d\\x16\\x19\\x00\\x83\\x01|\\x00d\\x16\u003c\\x00|\\x04\\xa0\\t|\\x00d\\x16\\x19\\x00\\xa1\\x01\\x01\\x00|\\x00d\\x16\\x19\\x00g\\x00d\\x17\\xa2\\x01k\\x03r\\xf0t\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00|\\x00d\\x18\\x19\\x00d\\x19\\x17\\x00d\\x1ak\\x03r\\xfet\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00t\\x00j\\x01j\\x02d\\x1b\\x19\\x00\\xa0\\n|\\x00d\\x1c\\x19\\x00d\\x0cd\\x18\\x85\\x02\\x19\\x00d\\x1d\\xa1\\x02|\\x04\\xa0\\x0bd\\x0cd\\x1e\\xa1\\x02A\\x00d\\x1fk\\x03\\x90\\x01r\\x1dt\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00t\\x00j\\x01j\\x02d\\x1b\\x19\\x00\\xa0\\n|\\x00d\\x1c\\x19\\x00d\\x18d \\x85\\x02\\x19\\x00d\\x1d\\xa1\\x02|\\x04\\xa0\\x0bd\\x0cd\\x1e\\xa1\\x02A\\x00d!k\\x03\\x90\\x01r\u003ct\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00t\\x00j\\x01j\\x02d\\x1b\\x19\\x00\\xa0\\n|\\x00d\\x1c\\x19\\x00d d\\x01\\x85\\x02\\x19\\x00d\"\\x17\\x00d\\x1d\\xa1\\x02|\\x04\\xa0\\x0bd\\x0cd\\x1e\\xa1\\x02A\\x00d#k\\x03\\x90\\x01r]t\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00d\\x0c}\\x05|\\x00d$\\x19\\x00D\\x00]\\x0b}\\x02|\\x05d%9\\x00}\\x05|\\x05|\\x027\\x00}\\x05\\x90\\x01qct\\x00j\\x01j\\x02d\u0026\\x19\\x00|\\x05\\x83\\x01d\\'k\\x03\\x90\\x01r\\x80t\\x00j\\x01j\\x02d\\x03\\x19\\x00S\\x00t\\x00j\\x01j\\x02d(\\x19\\x00S\\x00', (None, 12, 'amateursCTF{', 'False', -1, '}', 'len', 42, 'enumerate', '_', (7, 11, 13, 20, 23, 35), b'_', 0, b'sn0h7YP', 1, 2, (160, 68, 34), '__import__', 'hashlib', '4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a', 'random', 'list', 3, (49, 89, 102, 109, 108, 52), 4, b'freebie', b'0ffreebie', 'int', 5, 'little', 4294967295, 4227810561, 8, 825199122, b'\\x00', 4277086886, 6, 128, 'hex', '0x29ee69af2f","date":"2023-07-20","objectID":"/amateursctf2023-rev/:4:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"headache Challenge Information Given file: headache Description: Ugh… my head hurts… Flag is amateursCTF{[a-zA-Z0-9_]+} We are provided with a binary named headache. Using decompilers, we can see that the input should has length of 61. Dug a bit further into the checker, I see that this binary is a self-modifying binary. What is self-modifying binary A binary that self constructs during runtime (modifies its content to turn raw data into opcodes). __int64 __fastcall sub_401290(_BYTE *a1) { _DWORD *v2; // rsi if ( (*a1 ^ a1[25]) != 86 ) return 0LL; v2 = \u0026loc_4012A4; do *v2++ ^= 0xEA228DE6; while ( *(v2 - 1) != -366834202 ); return ((__int64 (*)(void))loc_4012A4)(); } So, how exactly this program works? Firstly, we can see that it checks whether input[0] ^ input[25] == 0x56. If that satisfies, the binary does some XOR operations to reveal new codes and call them. And after doing some debugging, I could see the scheme of this challenge. How the challenge works It keeps checking the input’s character pairs by pairs using bitwise XOR and compares the result with a constant. If they are equal, a new code section is unlocked - which also does the same thing, and the program calls it. Doing so for a reasonable amount of times, a set of constraint for the input is built. So how we gonna solve this? At first I was thinking of using angr, but I failed to do so (again, zer0ptsCTF 2023 flashbacks if you guys have read my last blog on that CTF), so I took the looooooong path of debugging and Z3 (which was really painful). While debugging, you can modify ZF runtime to skip the comparisons and come to the self-modifying parts. And, here is the script after all that debugging. (I also cheesed the flag and guessed it without putting all constraints in to save some time). from z3 import * s = Solver() a = [BitVec('x{}'.format(i), 8) for i in range(61)] for i in range(61): s.add(a[i] \u003c 127) s.add(a[i] \u003e= 32) s.add(a[i] != ord(' ')) for i in range(12): s.add(a[i] == ord('amateursCTF{'[i])) s.add(a[-1] == ord('}')) s.add(a[0] ^ a[25] == 0x56) s.add(a[0x0E] ^ a[0x2D] == 0x1D) s.add(a[0x21] ^ a[0x22] == 5) s.add(a[0x28] ^ a[0x34] == 5) s.add(a[0x0C] ^ a[0x38] == 5) s.add(a[0x0B] ^ a[4] == 0x1e) [...] sol_count = 0 while s.check() == sat and sol_count \u003c 10: result = s.model() for i in range(61): print(end=chr(result[a[i]].as_long())) print() sol_count += 1 cond = True for i in range(61): cond = And(cond, a[i] == result[a[i]]) s.add(Not(cond)) # amateursCTF{i_h4v3_a_spli77ing_headache_1_r3qu1re_m04r_sl33p} Flag is: amateursCTF{i_h4v3_a_spli77ing_headache_1_r3qu1re_m04r_sl33p} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:5:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"CSCE221-Data Structures and Algorithms Challenge Information Given file: csce221.tar.gz Description: I was doing some homework for my Data Structures and Algorithms class, but my program unexpectedly crashed when I entered in my flag. Could you help me get it back? Here’s the coredump and the binary, I’ll even toss in the header file. Can’t give out the source code though, how do I know you won’t cheat off me? For this challenge, I had an unintended intended solution (confirmed by the author himself that this is intended, I just took the shorter route instead) to just view the main.coredump file to get the flag. Sorry flocto for that! Flag is: amateursCTF{l1nk3d_bY_4n_xor} Appendix I looked at main and the header before, and combined with the flag’s content, probably the author’s intended solution is to mix bitwise XOR and linked list data structures? ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:6:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"jvm Challenge Information Given file: JVM.class and code.jvm Description: I heard my professor talking about some “Java Virtual Machine” and its weird gimmicks, so I took it upon myself to complete one. It wasn’t even that hard? I don’t know why he was complaining about it so much. Compiled with openjdk 11.0.19. Run with java JVM code.jvm. For this problem, we have two files, JVM.class and code.jvm. View JVM.class in JADX , we can see that this is an another VM reversing challenge. My way of tackling a VM challenge is to first, write a quick and dirty interpreter. vm = open(\"C:/Users/ADMIN/OneDrive/Desktop/temp/jvm/code.jvm\", 'rb').read() vm = [i for i in vm] ls = [0] * 1024 ls2 = [0] * 4 i = 0 i2 = 0 inp_stream = 'amateursCTF{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}' while i \u003c len(vm): op = vm[i] if op in [0, 1, 2, 3]: ls2[vm[i]], ls2[vm[i + 1]] = ls2[vm[i + 1]], ls2[vm[i]] print('op {}: swap ls2[{}] and ls2[{}].'.format(vm[i], vm[i], vm[i + 1])) i += 2 elif op == 8: ls2[vm[i + 1]] += vm[i + 2] print('op {}: ls2[{}] += {}.'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 9: ls2[vm[i + 1]] += ls2[vm[i + 2]] print('op {}: ls2[{}] += ls2[{}] = {}.'.format(vm[i], vm[i + 1], vm[i + 2], ls2[vm[i + 1]])) i += 3 elif op == 12: ls2[vm[i + 1]] -= vm[i + 2] print('op {}: ls2[{}] -= {}.'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 13: ls2[vm[i + 1]] -= ls2[vm[i + 2]] print('op {}: ls2[{}] -= ls2[{}] = {}.'.format(vm[i], vm[i + 1], vm[i + 2], ls2[vm[i + 1]])) i += 3 elif op == 16: ls2[vm[i + 1]] *= vm[i + 2] print('op {}: ls2[{}] *= {}.'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 17: ls2[vm[i + 1]] *= ls2[vm[i + 2]] print('op {}: ls2[{}] *= ls2[{}] = {}.'.format(vm[i], vm[i + 1], vm[i + 2], ls2[vm[i + 1]])) i += 3 elif op == 20: ls2[vm[i + 1]] //= vm[i + 2] print('op {}: ls2[{}] //= {}.'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 21: ls2[vm[i + 1]] //= ls2[vm[i + 2]] print('op {}: ls2[{}] //= ls2[{}] = {}.'.format(vm[i], vm[i + 1], vm[i + 2], ls2[vm[i + 1]])) i += 3 elif op == 24: ls2[vm[i + 1]] %= vm[i + 2] print('op {}: ls2[{}] %= {}.'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 25: ls2[vm[i + 1]] %= ls2[vm[i + 2]] print('op {}: ls2[{}] %= ls2[{}].'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 28: ls2[vm[i + 1]] \u003c\u003c= vm[i + 2] print('op {}: ls2[{}] \u003c\u003c= {}.'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 29: ls2[vm[i + 1]] \u003c\u003c= ls2[vm[i + 2]] print('op {}: ls2[{}] \u003c\u003c= ls2[{}].'.format(vm[i], vm[i + 1], vm[i + 2])) i += 3 elif op == 31: ls2[vm[i + 1]] = ord(inp_stream[0]) print('op {}: ls2[{}] = {}.'.format(vm[i], vm[i + 1], inp_stream[0])) inp_stream = inp_stream[1:] i += 2 elif op == 32: i4 = i2 i2 += 1 ls[i4] = ord(inp_stream[0]) print('op {}: ls[{}] = {}.'.format(vm[i], i4, inp_stream[0])) inp_stream = inp_stream[1:] i += 1 elif op == 33: print('op {}: print({}).'.format(vm[i], chr(ls2[vm[i + 1]]))) i += 2 elif op == 34: i2 -= 1 print('op {}: print({}).'.format(vm[i], chr(ls[i2]))) i += 1 elif op == 41: print('op {}: if {} == 0, i set to {}.'.format(vm[i], ls2[vm[i + 1]], vm[i + 2])) if ls2[vm[i + 1]] == 0: i = vm[i + 2] else: i += 3 elif op == 42: print('op {}: if ls2[{}] = {} != 0, i set to vm[{}] = {}.'.format(vm[i], vm[i + 1], ls2[vm[i + 1]], i + 2, vm[i + 2])) if ls2[vm[i + 1]] != 0: i = vm[i + 2] else: i += 3 elif op == 43: print('op {}: i set to vm[{}] = {}.'.format(vm[i], i + 1, vm[i + 1])) i = vm[i + 1] elif op == 52: i5 = i2 i2 += 1 ls[i5] = ls2[vm[i + 1]] print('op {}: ls[{}] = ls2[{}] = {}.'.format(vm[i], i5, vm[i + 1], ls[i5])) i += 2 elif op == 53: i2 -= 1 ls2[vm[i + 1]] = ls[i2] print('op {}: ls2[{}] = ls[{}] = {}.'.format(vm[i], vm[i + 1], i2, ls2[vm[i + 1]])) i += 2 elif op == 54: i6 = i2 i2 += 1 ls[i6] = vm[i + 1] print('op {}: ls[{}] = vm[{}] = {}.'.format(vm[i], i6, i + 1, ls[i6])) i += 2 elif op == 255: break After some trials and errors, I could see that the VM wants an input of length 45. I tried amateursCTF{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} as an inp","date":"2023-07-20","objectID":"/amateursctf2023-rev/:7:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"rusteze 2 Challenge Information Given file: rusteze-2.exe Description: My boss said Linux binaries wouldn’t reach enough customers so I was forced to make a Windows version. Flag is amateursCTF{[a-zA-Z0-9_]+}. We are given a Windows executable for this challenge. Load it in IDA, what I saw was a bunch of functions. Well, what should we do then? Normally, we can seek for main function. But in this case, we should seek for the strings that the executable outputs. We can do so via View \u003e Open subviews \u003e Strings. In this executable, we have two outputs Wrong! and Correct!. By clicking on their offsets then press X, you can view their xrefs and quickly get to the main encrypt function. The graph part above is our main target. First, it checks whether our input’s length is 35 or not, then it calls sub_1400029C0 for encryption. Basically, the encryption is almost the same with rusteze challenge above but with a small twist, that is we have to input a key instead, and the flag will be in the memory of the program. Here is how it works (with a, b, c are hardcoded arrays): assert rol(key[i] ^ a[i], 2) == b[i] flag[i] = a[i] ^ c[i] ^ key[i] From that, we can conclude in: flag[i] = rol(b[i], 6) ^ c[i]. Knowing the technique, I wrote a script to get the flag. def rol(a): k = bin(a)[2:].rjust(8, '0') k = k[6:] + k[:6] return int(k, 2) a = [210, 165, 246, 177, 31, 108, 51, 61, 132, 61, 46, 198, 143, 132, 35, 123, 163, 191, 118, 180, 203, 166, 29, 124, 36, 219, 245, 108, 149, 125, 86, 97, 133, 0x4D, 0x2F] b = [134, 43, 18, 15, 153, 204, 29, 85, 183, 57, 197, 190, 243, 171, 93, 144, 95, 95, 76, 175, 182, 43, 241, 108, 237, 190, 118, 20, 155, 136, 136, 32, 163, 160, 4] c = [0xC0, 0x0A7, 0x0E5, 0x0B7, 0x3, 0x46, 0x35, 0x26, 0x0AE, 0x1A, 0x37, 0x0D4, 0x98, 0x0DA, 0x39, 0x17, 0x88, 0x0E3, 0x7D, 0x8F, 0x0F2, 0x0AE, 0x19, 0x49, 0x0E, 0x0DC, 0x0E9, 0x36, 0x82, 0x5F] for i in range(len(c)): print(end=chr(rol(b[i]) ^ c[i])) # amateursCTF{d0n3_4nd_deRust3d} Flag is: amateursCTF{d0n3_4nd_deRust3d} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:8:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"flagchecker Challenge Information Given file: flagchecker.sb3 Description: I was making this simple flag checker in Scratch, but my friend logged into my account and messed up all my variable names. Can you help me recover my flag please? You should run on Turbowarp for better performance. We are given a scratch file .sb3 to work with. I used onine Scratch to open and edit the code. Looks like the code is obfuscated, and after a while cleaning up, I renamed all the functions to their usages. And the logic was really easy to understand after that, so here is the source code that I rewrote in Python. from Crypto.Util.number import * inp = input() inp_ls = [ord(i) for i in inp] res = [] while len(inp) != 0: t = bytes_to_long(inp[:4].encode()) u = bytes_to_long(inp[4:8].encode()) inp = inp[8:] val = 0 for i in range(32): val += 0x9E3779B9 val \u0026= 0xFFFFFFFF tmp = (u * 16 + 69420) \u0026 0xFFFFFFFF tmp ^= (u + val) \u0026 0xFFFFFFFF tmp ^= (u // 32 + 1412141) \u0026 0xFFFFFFFF t += tmp t \u0026= 0xFFFFFFFF tmp = (t * 16 + 1936419188) \u0026 0xFFFFFFFF tmp ^= (t + val) \u0026 0xFFFFFFFF tmp ^= (t // 32 + 1953260915) \u0026 0xFFFFFFFF u += tmp u \u0026= 0xFFFFFFFF res_new = [] for i in range(4): res_new = [u \u0026 0xFF] + res_new u //= 256 for i in range(4): res_new = [t \u0026 0xFF] + res_new t //= 256 res += res_new # print(res) assert res == [239, 202, 230, 114, 17, 147, 199, 39, 182, 230, 119, 248, 78, 246, 224, 46, 99, 164, 112, 134, 30, 216, 53, 194, 60, 75, 223, 122, 67, 202, 207, 56, 16, 128, 216, 142, 248, 16, 27, 202, 119, 105, 158, 232, 251, 201, 158, 69, 242, 193, 90, 191, 63, 96, 38, 164] To solve that, I wrote another script to start working backwards. from z3 import * from Crypto.Util.number import * res = [239, 202, 230, 114, 17, 147, 199, 39, 182, 230, 119, 248, 78, 246, 224, 46, 99, 164, 112, 134, 30, 216, 53, 194, 60, 75, 223, 122, 67, 202, 207, 56, 16, 128, 216, 142, 248, 16, 27, 202, 119, 105, 158, 232, 251, 201, 158, 69, 242, 193, 90, 191, 63, 96, 38, 164] ls = [] val = 0 for i in range(32): val += 0x9E3779B9 val \u0026= 0xFFFFFFFF ls.append(val) ls = ls[::-1] for i in range(0, len(res), 8): t = res[i + 3] + res[i + 2] * 256 + res[i + 1] * 256 * 256 + res[i] * 256 * 256 * 256 u = res[i + 7] + res[i + 6] * 256 + res[i + 5] * 256 * 256 + res[i + 4] * 256 * 256 * 256 for _ in range(32): tmp = (t * 16 + 1936419188) \u0026 0xFFFFFFFF tmp ^= (t + ls[_]) \u0026 0xFFFFFFFF tmp ^= (t // 32 + 1953260915) \u0026 0xFFFFFFFF if tmp \u003e u: u = 0xFFFFFFFF + 1 - (tmp - u) else: u = u - tmp tmp = (u * 16 + 69420) \u0026 0xFFFFFFFF tmp ^= (u + ls[_]) \u0026 0xFFFFFFFF tmp ^= (u // 32 + 1412141) \u0026 0xFFFFFFFF if tmp \u003e t: t = 0xFFFFFFFF + 1 - (tmp - t) else: t = t - tmp print(end=long_to_bytes(t).decode()) print(end=long_to_bytes(u).decode()) # amateursCTF{screw_scratch_llvm_we_code_by_hand_1a89c87b} Flag is: amateursCTF{screw_scratch_llvm_we_code_by_hand_1a89c87b} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:9:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"🏴❓🇨🇹🇫 Challenge Information Given file: emojis.tar.gz Description: I apologize in advance. Flag is amateursCTF{[a-z0-9_]+}. Compiled using the latest version of emojicode. Note that there may be multiple inputs that cause the program to print ✅. The correct input (and the flag) has sha256 hash 53cf379fa8fd802fd2f99b2aa395fe8b19b066ab5e2ff49e44633ce046c346c4. We are given a source written in emojicode. After a while researching the emojicode docs , I managed to rewrite the source code using Python, as below. from Crypto.Util.number import * egg = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []] bacon = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []] s = input() inp = '' for i in s: inp += bin(ord(i))[2:] if len(inp) \u003e 256: print(\"Wrong\") exit(0) for i in range(len(inp)): if inp[i] == '1': if len(egg[i % 16]) == 0: egg[i % 16].append(0) egg[i % 16][-1] += 1 if len(bacon[i // 16]) == 0: bacon[i // 16].append(0) bacon[i // 16][-1] += 1 else: if len(egg[i % 16]) \u003e 0 and egg[i % 16][-1] \u003e 0: egg[i % 16].append(0) if len(bacon[i // 16]) \u003e 0 and bacon[i // 16][-1] \u003e 0: bacon[i // 16].append(0) for i in range(16): if len(egg[i]) \u003e 0 and egg[i][-1] == 0: egg[i] = egg[i][:-1] if len(bacon[i]) \u003e 0 and bacon[i][-1] == 0: bacon[i] = bacon[i][:-1] res = 0 chicken = [[1, 1, 1, 2, 1], [1, 2, 10], [2, 3, 2, 1, 2], [4, 3, 1, 1], [2, 4, 4], [2, 1, 5, 1], [2, 2, 1, 3, 2], [4, 6, 1, 1], [1, 1, 2, 1, 2, 2], [2, 2, 5, 1], [1, 1, 3, 5, 1], [1, 1, 2, 2, 1, 3], [2, 1, 2, 3], [2, 5, 7], [1, 2, 6, 1], [1, 3, 1, 3, 3]] pig = [[2, 3, 2, 3], [4, 1, 2], [1, 4, 1, 4, 1], [3, 3, 3], [1, 1, 1, 2, 3], [1, 4, 5, 1], [2, 1, 4, 3], [7, 1, 2], [1, 3, 2, 2, 2], [4, 3, 2, 3], [3, 3, 7], [1, 3, 3, 3], [4, 3, 1], [2, 1, 2, 7], [2, 3, 1, 3, 1], [3, 7, 1]] for i in range(16): if chicken[i] == egg[i]: res += 1 if pig[i] == bacon[i]: res += 1 if res == 32: print(\"Correct\") else: print(\"Wrong\") print(res) # print(egg) # print(bacon) So our problem now becomes easier, just need to know how egg[] and bacon[] are generated. And that took me quite some time to realize that this is implementing the game nonogram , where chicken[] contains rules for columns and pig[] contains rules for rows. There are plenty of nonogram solvers online, but I chose to solve this manually (really enjoyed it xD). Here is the final solution: Solution 1100001110110111 0000111101001100 1011110101111001 0111001110000111 0101001000110111 1011110111110100 0110100111100111 0111111100010110 0101110110011011 1111011101100111 1110011101111111 0100111011101110 0111100011100100 1100101101111111 0110111010011101 0111000111111101 Then the only thing left is to convert it into readable characters. Here, since our characters might have either 6 or 7 bits, so we need to do some trials and errors to get it. (6 bits for numbers and 7 bits for any other characters of the regex in the description). I didn’t need to use the sha256 hash because the flag was easy to read! Flag is: amateursCTF{7his_belongs_ins1de_mi5c} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:10:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"jsrev Challenge Information Given link: jsrev.amt.rs Description: Someone wanted this, so I delivered. Have fun! We are given a game written in js. From index.js, I saw this loader.load( 'collision-world.glb', ( gltf ) and tried to view the 3D model of the map but found nothing. Then I saw this line const GRAVITY = 30;, and thought about why not just modify it to 0 to fly around? How to modify js locally Here is a great tutorial for doing that: Click me! After modified the GRAVITY variable to 0, I flew up using right click (it works like a jetpack) and saw the balls are stacked above in the sky. Take a closer look, I recognized that it is showing our characters of the flag, in a stack. It got more obvious when I saw this line await fetch('./coords.json') and that is where the coordinates of the balls are saved. I tried to plot them in Python using below script. import numpy as np import matplotlib.pyplot as plt fig = plt.figure() ax = plt.axes(projection='3d') ls = [[4.2, 50, 10.6], [4.2, 50, 11.0], [...], [5.4, 34.4, 11.0], [5.8, 34.4, 10.6]] a = (0, 472) x = [i[0] for i in ls][a[0]:a[1]] y = [i[1] for i in ls][a[0]:a[1]] z = [i[2] for i in ls][a[0]:a[1]] ax.scatter(x, y, z, 'green', marker='o') plt.show() At first, set a in the script to (0, 472) is really hard (impossible) to read the flag, so I tried to output the points in subgroups (ex. (0, 50), (50, 100), …). Here is the output if we set a in the script to (0, 15), which reveals letter a. And, here is the output if we set a in the script to (15, 30), which reveals letter m. We will eventually get the flag after a while! Flag is: amateursCTF{asK_4nD_thr33_5h4ll_r3c31v3} ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:11:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"Appendix The challenges were quite fun to solve, some of them were written in uncommon languages, which I think is really cool! If you have any question regarding the above solutions, you can DM me via my Twitter or my Discord (FazeCT #fazect). ","date":"2023-07-20","objectID":"/amateursctf2023-rev/:12:0","tags":["RE","amateursCTF","english"],"title":"amateursCTF 2023 - Reverse Engineering Writeups","uri":"/amateursctf2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition.","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition. ","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/:0:0","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"Overview I had a great time participating in the CTF with team thehackerscrew this week. Out of the four reverse engineering challenges, I managed to solve three, which was a fantastic accomplishment. The challenges were both enjoyable and educational, allowing me to learn and grow as I tackled them. ","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/:1:0","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"decompile me Challenge Information Given file: Get it here! Description: Reverse engineering is getting easier thanks to IDA/Ghidra decompiler! We are given a binary file named chall. Load it in IDA, and it was easy to see that the binary just does RC4 encryption on the input we provide it. However, when I tried to decrypt the ciphertext using the key given, I failed to get the flag. At this point I read the description again and saw that it said something about IDA/Ghidra, and my thought was that IDA and Ghidra might give false results. So I went on and tried to decompile the binary using Binary Ninja instead. And my thought was correct, key and enc was wrongly mapped. I wrote a simple script to get the flag. from malduck import rc4 key = b'1\\t\\x81\\x19\\x19\\x14E\\x11' enc = b'x\\xcf\\xc4\\x85\\xdc3\\x07L\\x935\\xfb|\\x10\\x8e\\xbe\\x93(\\xe6.u\\xda^\\x85\\xc5\\x91\\x15u\\x89H\\x0e)\\xa4\\xf9\\xa6:n\\x1f\\x84\\xf7B\\xb0\\x931\\xf0h\\xc0C8\\x072\\tW\\xda2D\\xcf\\xcd\\x8f\\xe5\\xbf\\xe3\\xd6\\xbbY\\x9aj\\x84\\x85\\xd3\\\"\\xa9\\x8e\\xb5\\xea\\xbdW\\xde\\xb1l\\x93\\xe4tp\\xac\\x1a\\x03\\xd9\\x16\\x9f\\xbc\\x97\\xfb\\x85\\xd9\\xa6\\x9e\\xd4\\xd6\\x02Y\\xd5(\\xb3\\x93\\x16\\xb6\\xc4x\\xc4\\xa2\\x12\\xd2\\xef\\xb1T\\x18\\xfdvQ\\xa3^W\\xb8XK\\x1e\\xe2A' print(rc4(key, enc)) Flag is: zer0pts{d0n'7_4lw4y5_7ru57_d3c0mp1l3r} ","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/:2:0","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"mimikyu Challenge Information Given file: Get it here! Description: Deja vu in Windows. For this challenge, we are given a binary and 2 library files. A quick look into the binary reveals that it is using dynamic linking in the implementation of the program. How the binary works? To briefly explain, ResolveModuleFunction() is used with a hash value to retrieve functions from a library file (which we call dynamic linking). So first thing we should do is to retrieve all the functions called. That should be fairly easy with some debuggings, since dlsym() function directly returns function name from the library. How to get function names? Set a breakpoint at dlsym() call and read parameter name. After a while, I saw that our flag is splitted into chunks of 4 bytes, and the scheme of the checker should look like this: encoded = pow(chunks[i], e, m) with e and m are the values we get from rand() calls. I’ve been doing both Crypto and Reversing, so I quickly realized that this is just doing RSA encryption. So I wrote a script, with some debuggings to retrieve rand() values runtime, and I got the flag. from Crypto.Util.number import * from factordb.factordb import FactorDB x = [0xf0d3, 0x085f, 0x8e63, 0x8249, 0xc6a1, 0x0c6d, 0xaef5, 0xd5df, 0xe68d, 0xf3fb] y = [0x00002350f23a0dff, 0x000032d18e9d4d33, 0x000003866cd71f1b, 0x000010ae9be3fc8f, 0x000009d942eff67d, 0x00001de2e3aa8bb1, 0x0000103fc65841f3, 0x0000011a0970edc9, 0x00005f8d20bddf39, 0x000045b14e11e0ed] enc = [0xFE4C025C5F4, 0x1B792FF17E8A, 0x183B156AB40, 0xBEFFCF5E5DA, 0x297CF86E251, 0xEB3EDC1D4B4, 0xFA10CE3A08, 0x2BDD418672, 0x5EBB5050EA46, 0x5BF9B73CF86] flag = b\"\" for i in range(len(x)): f = FactorDB(y[i]) f.connect() ls = f.get_factor_list() phi = 1 for j in ls: phi *= (j - 1) d = inverse(x[i], phi) dec = pow(enc[i], d, y[i]).to_bytes(4, \"little\") flag += dec print(flag.decode()) Flag is: zer0pts{L00k_th3_1nt3rn4l_0f_l1br4r13s!} ","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/:3:0","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"topology Challenge Information Given file: Get it here! Description: No worries. It’s a network topology, not an algebraic one. For this challenge, we are provided with a binary file, topology. I did some analysis on it, and noted out some comments about how the challenge works. My note Input is splitted into 10 chunks, each has 8 bytes. The parent process spawns many child process, each has a different whoami value. Each child process is linked with a function, which is derived from f[whoami - 1] (in handle_message). Each function has 10 cases, each case has a unique solution to make result = 0 (so that OK is sent from the child process back to the parent process). Suppose that the first time a function is called, case 0 is used to check the input, and next time case 1 is used, and so on. Move on to the main check function in network_main, and here is where things get more obvious. How the checker works? The first chunk of the input is checked using case 0 of all the functions (that is linked with all child processes). Similarly, the second chunk of the input is checked using case 1 of all the functions (since all of them are already called once), and thing goes the same for all remaining chunks of the input. A chunk is considered correct if at least 5 functions accept it. So our problem is how to solve the cases. At first I was thinking of using angr, but I failed to do so, and I ended up using z3 to solve them. Below is the example of solving a case which leads to the first chunk of our flag: from z3 import * from Crypto.Util.number import * s = Solver() x = BitVec(\"x\", 64) def _byteswap_uint64(x): chunks = [Extract((i + 1) * 8 - 1, i * 8, x) for i in range(8)] reversed_chunks = chunks return Concat(reversed_chunks) def __ROL8__(x, a): return RotateLeft(x, a) def __ROR8__(x, a): return RotateRight(x, a) s.add( __ROL8__( _byteswap_uint64( [...] ), 12, ) == 0x6AA189484E6B1D4 ) if s.check() == sat: result = s.model() print(long_to_bytes(result[x].as_long()).decode()[::-1]) # zer0pts{ To know which chunk is correct, we can set a breakpoint at base + 0xE5C6F and read ebp register to know the amount of functions that accept it. And, here is my note again, and this time it contains the flag instead. My note 1 zer0pts{ 2 kMo7UtDh 3 qMfXhaUp 4 0kP8MEPL 5 PJFgKUx7 6 YlWyyxB9 7 POKUhegF 8 qdNm5sXI 9 fxk2FIfV 10 } Flag is: zer0pts{kMo7UtDhqMfXhaUp0kP8MEPLPJFgKUx7YlWyyxB9POKUhegFqdNm5sXIfxk2FIfV} ","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/:4:0","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"fvm Challenge Information Given file: Get it here! Description: Are you bored with x86? Enjoy this x87 VM. Too bad I didn’t solve it at the end, was really sleepy for the whole last 12 hours of the CTF, but anyway here is the interpreter me and my teammates wrote for the VM before I went to sleep and stopped doing it. import decimal import math class VM: def __init__(self): self.stack = [] self.memory = [decimal.Decimal(0)] * 20 self.opcodes = { '!': self.opcode_exclamation, '\"': self.opcode_quote, '#': self.opcode_hash, '$': self.opcode_dollar, '%': self.opcode_percent, '\u0026': self.opcode_ampersand, '\\'': self.opcode_single_quote, '1': self.opcode_1, '2': self.opcode_2, '3': self.opcode_3, '4': self.opcode_4, '5': self.opcode_5, '6': self.opcode_6, '7': self.opcode_7, '8': self.opcode_8, ':': self.opcode_colon, 'A': self.opcode_A, 'B': self.opcode_B, 'C': self.opcode_C, 'D': self.opcode_D, 'E': self.opcode_E, 'Q': self.opcode_Q, 'R': self.opcode_R, 'S': self.opcode_S, 'T': self.opcode_T, 'a': self.opcode_a, 'b': self.opcode_b, #'c': self.opcode_c, 'd': self.opcode_d, 'e': self.opcode_e, 'f': self.opcode_f, 'g': self.opcode_g, 'h': self.opcode_h, 'i': self.opcode_i, '9': self.opcode_9, 'r': self.opcode_r, 's': self.opcode_s, } def interpret(self, code): for opcode in code: func = self.opcodes.get(opcode, self.opcode_default) func() # print(self.stack) def opcode_default(self): raise ValueError(\"Invalid or unsupported opcode\") def opcode_exclamation(self): self.stack.append(decimal.Decimal(0.0)) def opcode_quote(self): self.stack.append(decimal.Decimal(1.0)) def opcode_hash(self): self.stack.append(decimal.Decimal(math.pi)) def opcode_dollar(self): self.stack.append(decimal.Decimal(math.log2(10))) def opcode_percent(self): self.stack.append(decimal.Decimal(math.log2(math.e))) def opcode_ampersand(self): self.stack.append(decimal.Decimal(math.log10(2))) def opcode_single_quote(self): self.stack.append(decimal.Decimal(math.log(2, math.e))) def opcode_8(self): self.stack.append(self.stack[-1]) def opcode_colon(self): self.stack = self.stack.pop() def opcode_A(self): self.stack.append(self.stack.pop() + self.stack.pop()) def opcode_B(self): self.stack.append(self.stack.pop(-2) - self.stack.pop()) def opcode_C(self): self.stack.append(self.stack.pop() * self.stack.pop()) def opcode_D(self): self.stack.append(self.stack.pop(-2) / self.stack.pop()) def opcode_E(self): self.stack[-1] *= decimal.Decimal(-1) def opcode_Q(self): self.stack[-1] = decimal.Decimal(math.sqrt(self.stack[-1])) def opcode_R(self): self.stack[-1] = decimal.Decimal(math.sin(self.stack[-1])) def opcode_S(self): self.stack[-1] = decimal.Decimal(math.cos(self.stack[-1])) def opcode_T(self): self.stack[-1] = decimal.Decimal(round(self.stack[-1])) def opcode_a(self): self.memory[13] = self.stack.pop() def opcode_b(self): self.stack.append(self.memory[13]) def opcode_d(self): self.flags = int(self.stack.pop() \u003c self.stack.pop()) def opcode_e(self): self.flags = int(self.stack.pop() \u003c= self.stack.pop()) def opcode_f(self): self.flags = int(self.stack.pop() == self.stack.pop()) def opcode_g(self): self.flags = int(self.stack.pop() != self.stack.pop()) def opcode_h(self): self.flags = int(self.stack.pop() \u003e= self.stack.pop()) def opcode_i(self): for _ in range(self.flags): if self.code: self.code.pop(0) def opcode_r(self): self.stack.append(decimal.Decimal(ord(input(\"Enter a character: \")))) def opcode_s(self): print(chr(int(self.stack.pop())), end='') def opcode_1(self): self.stack[0], self.stack[1] = self.stack[1], self.stack[0] def opcode_2(self): self.stack[0], self.stack[2] = self.stack[2], self.stack[0] def opcode_3(self): self.stack[0], self.stack[3] = self.stack[3], self.stack[0] def opcode_4(self): self.stack[0], self.stack[4] = self.stack[4], self.stack[0] def opcode_5(self): self.stack[0], self.stack[5] = self.stack[5], self.stack[0] def opcode_6(self): self.stack[0], self.stack[6] = self.stack[6], self.stack[0] def opcode_7(self): self.stack[0], self.stack[7] = s","date":"2023-07-16","objectID":"/zer0ptsctf2023-rev/:5:0","tags":["RE","zer0ptsCTF","english"],"title":"zer0ptsCTF 2023 - Reverse Engineering Writeups","uri":"/zer0ptsctf2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition.","date":"2023-06-12","objectID":"/seetf2023-rev/","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition. ","date":"2023-06-12","objectID":"/seetf2023-rev/:0:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"Overview Despite my limited time for CTFs this week, I solved 5 out of 8 reverse challenges. The challenges (that I did) were quite fun, and without further ado, let’s hop into the solutions! ","date":"2023-06-12","objectID":"/seetf2023-rev/:1:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"decompile-me Challenge Information Given file: Get it here! Description: GO DECOMPILE ME NOW!!! We are given 2 files, decompile-me.pyc and output.txt. For decompile-me.pyc, I used uncompyle6 to decompile pyc file to python source code. We get the following Python source to work with. from pwn import xor with open('flag.txt', 'rb') as (f): flag = f.read() a = flag[0:len(flag) // 3] b = flag[len(flag) // 3:2 * len(flag) // 3] c = flag[2 * len(flag) // 3:] a = xor(a, int(str(len(flag))[0]) + int(str(len(flag))[1])) b = xor(a, b) c = xor(b, c) a = xor(c, a) b = xor(a, b) c = xor(b, c) c = xor(c, int(str(len(flag))[0]) * int(str(len(flag))[1])) enc = a + b + c with open('output.txt', 'wb') as (f): f.write(enc) Quite tricky at first, but after a while, I got the flag using the script below. from pwn import xor with open('D:/ctf/revChalls/SEETF 2023/decompile-me/output.txt', 'rb') as f: i = f.read() a, b, c = i[0:9], i[9:18], i[18:27] tmp_a = xor(b, b'l_D3c0mp1', a, 9) tmp_b = xor(c, 14) # b'l_D3c0mp1' tmp_c = xor(a, b'l_D3c0mp1') print((tmp_a + tmp_b + tmp_c).decode()) Flag is: SEE{s1mP4l_D3c0mp1l3r_XDXD} ","date":"2023-06-12","objectID":"/seetf2023-rev/:2:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"Data Structures and Algorithms Challenge Information Given file: Get it here! Description: It’s your second semester in SEE-IA, and they’re making you learn about data structures \u0026 algorithms. You don’t get what it has to do with anything you’ll be doing - how does capturing a bunch of escaped hackers need boring linked lists and trees? Classes are so boring, and sometimes you wish you could just drop out if the fate of the world wasn’t hanging in the balance. But oh well, this is your last assignment. Better do a good job of it! We are given an executable for this challenge. Load the executable into IDA, I immediately recognized that in sub_140001970, some Postfix Expressions are initiated (I learned DSA at my university before). Below is the first one implemented in sub_140001970. sub_14000F050(v2340, \"2\"); sub_14000F050(v2341, \"2\"); sub_14000F050(v2342, \"*\"); sub_14000F050(v2343, \"2\"); sub_14000F050(v2344, \"*\"); sub_14000F050(v2345, \"7\"); sub_14000F050(v2346, \"+\"); sub_14000F050(v2347, \"2\"); sub_14000F050(v2348, \"2\"); sub_14000F050(v2349, \"*\"); sub_14000F050(v2350, \"2\"); sub_14000F050(v2351, \"*\"); sub_14000F050(v2352, \"+\"); sub_14000F050(v2353, \"2\"); sub_14000F050(v2354, \"2\"); sub_14000F050(v2355, \"*\"); sub_14000F050(v2356, \"2\"); sub_14000F050(v2357, \"*\"); sub_14000F050(v2358, \"+\"); sub_14000F050(v2359, \"7\"); sub_14000F050(v2360, \"+\"); sub_14000F050(v2361, \"2\"); sub_14000F050(v2362, \"2\"); sub_14000F050(v2363, \"*\"); sub_14000F050(v2364, \"3\"); sub_14000F050(v2365, \"*\"); sub_14000F050(v2366, \"+\"); sub_14000F050(v2367, \"7\"); sub_14000F050(v2368, \"+\"); sub_14000F050(v2369, \"2\"); sub_14000F050(v2370, \"2\"); sub_14000F050(v2371, \"*\"); sub_14000F050(v2372, \"2\"); sub_14000F050(v2373, \"*\"); sub_14000F050(v2374, \"+\"); sub_14000F050(v2375, \"2\"); sub_14000F050(v2376, \"5\"); sub_14000F050(v2377, \"*\"); sub_14000F050(v2378, \"+\"); sub_14000F050(v2379, \"2\"); sub_14000F050(v2380, \"2\"); sub_14000F050(v2381, \"*\"); sub_14000F050(v2382, \"2\"); sub_14000F050(v2383, \"*\"); sub_14000F050(v2384, \"+\"); We get 2 2 * 2 * 7 + 2 2 * 2 * + 2 2 * 2 * + 7 + 2 2 * 3 * + 7 + 2 2 * 2 * + 2 5 * + 2 2 * 2 * + as our postfix expression. Test it out on this postfix calculator , we get 83, which maps to character S. At this point, I was quite confident to conclude that each postfix expression calculates the ASCII value of a character in our flag. Dumped out each expression, then used the below script for each expression, I got the flag. def evaluate_postfix(expression): stack = [] tokens = expression.split() for token in tokens: if token.isdigit(): stack.append(int(token)) else: operand2 = stack.pop() operand1 = stack.pop() result = perform_operation(token, operand1, operand2) stack.append(result) return stack.pop() def perform_operation(operator, operand1, operand2): if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': return operand1 / operand2 A second-blood for BKISC! Flag is: SEE{5w1n61n6_7hr0u6h_7h3_7r335_51e72e7f398a4fb0e3b8cg8457167552} ","date":"2023-06-12","objectID":"/seetf2023-rev/:3:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"Woodchecker Challenge Information Given file: Get it here! Description: Entering the realm of the Woodpecker’s Nest, you discover that the Woodpecker is nothing more than a low-level drone that only knows four instructions. Decode the enigmatic instructions and unveil the secrets that soar beyond the skies. A VM reverse challenge with 2 files given, cpu.py and woodchecker.wpk. Analyze the given cpu.py, we can see that our VM supports 4 opcodes, INC, INV, LOAD and CDEC. To tackle a VM-based challenge, we should first write a script to interpret the function calls. Below are the interpreter and result with input SEE{aaaaaaaaaaaaaaaa. f = open(\"D:/ctf/revChalls/SEETF 2023/Woodchecker/woodchecker.wpk\").readlines() flag = b\"SEE{aaaaaaaaaaaaaaaa\" addr = 0 store = 0 mem = bytearray(1 \u003c\u003c 29) mem[:len(flag)] = flag op = 0 cnt = 0 for i in f: if 'INC' in i: addr += 1 print('addr +=1, addr =', addr) elif 'INV' in i: mem[addr // 8] ^= 1 \u003c\u003c (addr % 8) print('mem[' + str(addr // 8) + '] ^= 1 \u003c\u003c (' + str(addr % 8) + '), mem[addr // 8] =', mem[addr // 8]) elif 'LOAD' in i: store = mem[addr // 8] \u003e\u003e (addr % 8) \u0026 1 print('store = mem[' + str(addr // 8) + '] \u003e\u003e (' + str(addr % 8) + ') \u0026 1, store =', store) elif 'CDEC' in i: addr -= store print('addr -= store, addr =', addr) addr +=1, addr = 1 addr +=1, addr = 2 addr +=1, addr = 3 addr +=1, addr = 4 addr +=1, addr = 5 [...] store = mem[20] \u003e\u003e (0) \u0026 1, store = 1 addr -= store, addr = 159 store = mem[19] \u003e\u003e (7) \u0026 1, store = 1 addr -= store, addr = 158 store = mem[19] \u003e\u003e (6) \u0026 1, store = 1 addr -= store, addr = 157 store = mem[19] \u003e\u003e (5) \u0026 1, store = 1 addr -= store, addr = 156 store = mem[19] \u003e\u003e (4) \u0026 1, store = 0 addr -= store, addr = 156 store = mem[19] \u003e\u003e (4) \u0026 1, store = 0 addr -= store, addr = 156 store = mem[19] \u003e\u003e (4) \u0026 1, store = 0 addr -= store, addr = 156 store = mem[19] \u003e\u003e (4) \u0026 1, store = 0 addr -= store, addr = 156 store = mem[19] \u003e\u003e (4) \u0026 1, store = 0 addr -= store, addr = 156 [...] By reading the result above, I came to some conclusions. How the VM works Our input is saved in mem[0:20]. The VM does some encryption (which I didn’t really care much about). The part mem[0:20] is checked. Looking closer at the output, we can see that the part mem[0:20] is checked backward, from this I tried to input SEE{aaaaaaaaaaaaaaa} to see what happens next. store = mem[20] \u003e\u003e (0) \u0026 1, store = 1 addr -= store, addr = 159 store = mem[19] \u003e\u003e (7) \u0026 1, store = 1 addr -= store, addr = 158 store = mem[19] \u003e\u003e (6) \u0026 1, store = 1 addr -= store, addr = 157 store = mem[19] \u003e\u003e (5) \u0026 1, store = 1 addr -= store, addr = 156 store = mem[19] \u003e\u003e (4) \u0026 1, store = 1 addr -= store, addr = 155 store = mem[19] \u003e\u003e (3) \u0026 1, store = 1 addr -= store, addr = 154 store = mem[19] \u003e\u003e (2) \u0026 1, store = 1 addr -= store, addr = 153 store = mem[19] \u003e\u003e (1) \u0026 1, store = 1 addr -= store, addr = 152 store = mem[19] \u003e\u003e (0) \u0026 1, store = 1 addr -= store, addr = 151 store = mem[18] \u003e\u003e (7) \u0026 1, store = 1 addr -= store, addr = 150 store = mem[18] \u003e\u003e (6) \u0026 1, store = 1 addr -= store, addr = 149 store = mem[18] \u003e\u003e (5) \u0026 1, store = 0 addr -= store, addr = 149 store = mem[18] \u003e\u003e (5) \u0026 1, store = 0 addr -= store, addr = 149 store = mem[18] \u003e\u003e (5) \u0026 1, store = 0 addr -= store, addr = 149 [...] This unraveled the last part (i.e. the part that checks mem[0:20]). The program checks backward, bit-by-bit (also backward), and if that bit is correct, the VM sets store = 1 to let the addr moves to the next position to check. Else, the addr would stuck and never changes its position again. From this, I wrote a script to bruteforce each character of the flag, backward. f = open(\"D:/ctf/revChalls/SEETF 2023/Woodchecker/woodchecker.wpk\").readlines() base2 = 482 out = b'' for _ in range(20): base = base2 for ch in range(32, 128): flag = chr(ch).encode() + out while len(flag) \u003c 20: flag = b'a' + flag addr = 0 store = 0 mem = bytearray(1 \u003c\u003c 29) mem[:len(flag)] = flag op = 0 cnt = 0 for i in f: if 'INC' in i: addr += 1 elif 'INV' in i: mem[addr // 8] ^= 1 \u003c\u003c (addr % ","date":"2023-06-12","objectID":"/seetf2023-rev/:4:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"Sleight of Hand Challenge Information Given file: Get it here! Description: Yet another flag encryptor, but this time with an embedded magic trick. Encrypted Flag: fde5f5e12640b9860f526a9601861e752e84d866825c415549f454fe8ba3. The password for the ZIP file is infected. While the binary will not harm your system, I suggest analyzing everything in a Virtual Machine with antiviruses switched off. We are given an executable to work with. Load it in IDA, and from the bunch of functions, sub_EC1260() looks like the main function of the encryptor. Encryption sub_EC1070: A keystream is generated from the passphrase hithisisakey, using RC4 KSA. sub_EC1140: Encrypts the plaintext using above keystream. From sub_EC1140(), we can easily see that each character of the input is encrypted separately. Knowing that, I wrote a script to bruteforce the input (again?). from pwn import * enc = 'fde5f5e12640b9860f526a9601861e752e84d866825c415549f454fe8ba3' flag = 'SEE{' while flag[-1] != '}': for ch in range(32, 127): arg = flag + chr(ch) io = process([\"/mnt/d/ctf/revChalls/SEETF 2023/Sleight of Hand/sleight-of-hand.exe\", arg]) ct = io.recv().decode().split(' ')[1] if ct in enc: flag += chr(ch) print(flag) break Since pwntools doesn’t let us open too many processes, we should bruteforce and append the result into the flag variable, and by doing so many times, we get our flag. Flag is: SEE{y0u_saw_thr0ugh_mY_tr1ck!} ","date":"2023-06-12","objectID":"/seetf2023-rev/:5:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"NOW Challenge Information Given file: Get it here! Description: Aaaa why does this binary take so long?! I want the flag NOW, N. O. W. NOW!!!!! We are given a 64-bit ELF file to work with. Decompile it using IDA, and we are greeted with sub_12FE(), sub_1A48() and some big hex strings. sub_12FE() is simply just invert a hex string (e.g. abcd would evaluate into 5432). sub_1A48() is more complicated, and by analyzing that function, I quickly realized that it does Modular Exponentiation , using an algorithm with O(log2n) complexity. I then greedily wrote a script to try calculating the flag, as below. from Crypto.Util.number import * # v1 = 'e7787d3f8c184210c0f99dc6ea823ab6334e2d9ae8acaa00d94eed4ef44e68ad76343fea24e2ccfb4ae358a7101e85ae23a3df24149748677b4f7b062a55ad726539dd51844efda612c38edd194d6c6b5117b569bce7a9cbc4b4bc3f73eab892b1795ca60e485aebe900fcdef242c2344d407e9d06b05e77db8c27c37552bd902a4a520f79f3e1a5e9fd3f182f5e16e117bbdbfe3225a45ce956181cc16f166a58abcbe345543709d1703acc8a27d9eaadcf1d67544ce45ce83985d1c5e45cc3a89f46faa80876f906aa444b7a520a9f1d1eec068c559b35b92f062cbae2e5bcc279c3ff93460ea04649696067854b3dd699e92992a8b883e0f4d291bbe79417d5defe75baa3c9de6cef7279d4cb19d1f40eedf90928165f3d4be915e206cdeb732f1fda3c3fd88ca089719cb3ef38c6040602625e466765c47637185605bece27a0640f42d29e78aa233735402c795b8401b70e72fae7e9bb24696b41844e24f3b197a277cf603aa25127028023de12044efa4b020202e2acdb5612e990556599d4c0f9fc37404dcf5d4ab07dc4ba8b0d0e03420a08db3e0a85faa77d2538ba11f64269e7ae049cc83e45780c0ed9f7c101dcf8dac55b5edc04a00a806f496beee6f33680eab37da22061573f8c933226b1a8e3af754ceba20c42786e78a6a30c19e46f5a7e12ce989a67ab84c79a8f3c571e32af64d031bf3b2c65538b4a19' v1 = '188782c073e7bdef3f066239157dc549ccb1d265175355ff26b112b10bb1975289cbc015db1d3304b51ca758efe17a51dc5c20dbeb68b79884b084f9d5aa528d9ac622ae7bb10259ed3c7122e6b29394aee84a96431856343b4b43c08c15476d4e86a359f1b7a51416ff03210dbd3dcbb2bf8162f94fa1882473d83c8aad426fd5b5adf0860c1e5a1602c0e7d0a1e91ee8442401cdda5ba316a9e7e33e90e995a754341cbaabc8f62e8fc53375d826155230e298abb31ba317c67a2e3a1ba33c5760b90557f78906f955bbb485adf560e2e113f973aa64ca46d0f9d3451d1a433d863c006cb9f15fb9b6969f987ab4c2296616d66d57477c1f0b2d6e44186be82a21018a455c362193108d862b34e62e0bf11206f6d7e9a0c2b416ea1df932148cd0e025c3c027735f768e634c10c739fbf9fd9da1b9989a3b89c8e7a9fa4131d85f9bf0bd2d618755dcc8cabfd386a47bfe48f18d05181644db9694be7bb1db0c4e685d88309fc55daed8fd7fdc21edfbb105b4fdfdfd1d5324a9ed166faa9a662b3f0603c8bfb230a2b54f823b4574f2f1fcbdf5f724c1f57a055882dac745ee09bd961851fb6337c1ba87f3f126083efe2307253aa4a123fb5ff57f90b69411190cc97f154c825ddf9ea8c0736ccdd94e571c508ab3145df3bd879187595cf3e61b90a581ed31676598547b386570c3a8e1cd509b2fce40c4d39aac74b5e6' v2 = '72feecd39ab2b416966c16b6cfa3b55ce50ffa5d02dbca44d56377be2d8f00e8f8df5548651b1ea37ffe37b9937a0673b1d5756f057625f76c82a6e9daa180baaef543e3bac57c95326e65315831d76b766d354495a2e233d76bfe80b404c0d254ecdc4107704966d1cd959bb26802a7d505250710047497b5dfde45bd9164700d5d3dfa40900fbaa02ae1a047eaac262d1069211fe0b39d86516dde1fe3144120bcbecf6a0c8a50d068cff5b55a1187765bfefc288f5c511ff217c2f435f2ff4524b513d8625aa87239f287423febb8ada47b0f6aaeac71be7355b4e9b12c20de815a052108edc78325b3b3a993ee4612efd17a30626d375f0669adb2632222c5a922cef0a515d848877b2f440f38b3554decd8fda0327995df2a64a426088389495caf89a540a69d2c048d46a29d9d90a560deb1859898398d46a3fe8070d07a34e1da5f8108c2f0a1012e76f422c09a6847cf9b16653c77bca3e3939e14dc01a2757b32ff0ccf0ab62d28c8266c8e1f47e7e25a444e48ffd4f0288e158a9404947786a11e869b6fdc3204b9fc433ba28ac77775ff4b51b1df668154d32e30b01a0ff5968f9bb7b4f5bc772ffc4b1c5af1859dae67552e077f650842c60f4fe1929468f5a701b66bdd9d01c1ce22496c49091f225a26987e3e0f2d7a7f27ab20fd3448450794835477786f6b9a97bf4d4091c9b261d75d62120138b3104f76' v3 = '780c9276bf474a488e56d5ec3a4827b8cffeca20cfb3dc5f53b25bc6b4d61152de663e13613222d8b1425a4e3329ac9b302586a0a097e74058466d070fba734ceedde9ef151611e937f249cb4f70e303efc2a96a0b586757a2bb517019aecc9a2cf2bbf6ffc0b496276a2366d2d0131d2829829a100a37e0da3a755aa6ab37243","date":"2023-06-12","objectID":"/seetf2023-rev/:6:0","tags":["RE","SEETF","english"],"title":"SEETF 2023 - Reverse Engineering Writeups","uri":"/seetf2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition.","date":"2023-04-27","objectID":"/angstrom2023-rev/","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition. Also check out our team’s blogs at BKISC Blog for other challenges/categories. ","date":"2023-04-27","objectID":"/angstrom2023-rev/:0:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"Overview Our team, BKISC finished at top 17 of this year ångstromCTF, got 2550 points in total. For reverse, we got 5 out of 8 challenges pwn-ed. Without further ado, let’s hop into this year’s ångstromCTF - REV category. ","date":"2023-04-27","objectID":"/angstrom2023-rev/:1:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"checkers Challenge Information Given file: Get it here! Description: None Category: Reverse Engineering Points: 20 We are given a 64-bit ELF file to work with. Since ångstromCTF always has a very easy Reverse challenge for us to warm up, I decided to just use strings checkers | grep -i 'actf{' to get the flag. Flag is: actf{ive_be3n_checkm4ted_21d1b2cebabf983f} ","date":"2023-04-27","objectID":"/angstrom2023-rev/:2:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"zaza Challenge Information Given file: Get it here! Description: Bedtime! Remote: nc challs.actf.co 32760 Points: 50 Once again we are given a 64-bit ELF file to work with. I used IDA Pro to get the decompiled source code, which looks like this. int __cdecl main(int argc, const char **argv, const char **envp) { int v5; // [rsp+8h] [rbp-58h] BYREF unsigned int v6; // [rsp+Ch] [rbp-54h] BYREF char s[72]; // [rsp+10h] [rbp-50h] BYREF unsigned __int64 v8; // [rsp+58h] [rbp-8h] v8 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); v5 = 0; v6 = 0; printf(\"I'm going to sleep. Count me some sheep: \"); __isoc99_scanf(\"%d\", \u0026v5); if ( v5 != 4919 ) { puts(\"That's not enough sheep!\"); exit(1); } printf(\"Nice, now reset it. Bet you can't: \"); __isoc99_scanf(\"%d\", \u0026v6); if ( v5 * v6 == 1 ) { printf(\"%d %d\", v6, v6 + v5); puts(\"Not good enough for me.\"); exit(1); } puts(\"Okay, what's the magic word?\"); getchar(); fgets(s, 64, stdin); s[strcspn(s, \"\\n\")] = 0; xor_((__int64)s); if ( strncmp(s, \"2\u0026 =$!-( \u003c*+*( ?!\u0026$$6,. )' $19 , #9=!1 \u003c*=6 \u003c6;66#\", 0x32uLL) ) { puts(\"Nope\"); exit(1); } win(); return v8 - __readfsqword(0x28u); } printf(\"I'm going to sleep. Count me some sheep: \"); __isoc99_scanf(\"%d\", \u0026v5); if ( v5 != 4919 ) { puts(\"That's not enough sheep!\"); exit(1); } We can easily observe that, for the first scanf, we will have to input 4919 to pass the check. printf(\"Nice, now reset it. Bet you can't: \"); __isoc99_scanf(\"%d\", \u0026v6); if ( v5 * v6 == 1 ) { printf(\"%d %d\", v6, v6 + v5); puts(\"Not good enough for me.\"); exit(1); } For this check, we will have to input a number x so that x * 4919 != 1. Let’s input 1 to pass this check (or anything that doesn’t satisfy the equation x * 4919 == 1). puts(\"Okay, what's the magic word?\"); getchar(); fgets(s, 64, stdin); s[strcspn(s, \"\\n\")] = 0; xor_((__int64)s); if ( strncmp(s, \"2\u0026 =$!-( \u003c*+*( ?!\u0026$$6,. )' $19 , #9=!1 \u003c*=6 \u003c6;66#\", 0x32uLL) ) { puts(\"Nope\"); exit(1); } win(); For this last check, the program prompts us to input a string, which will go through a XOR function and will be compared against 2\u0026 =$!-( \u003c*+*( ?!\u0026$$6,. )' $19 , #9=!1 \u003c*=6 \u003c6;66#. size_t __fastcall xor_(__int64 a1) { size_t result; // rax int i; // [rsp+14h] [rbp-1Ch] for ( i = 0; ; ++i ) { result = strlen(\"anextremelycomplicatedkeythatisdefinitelyuselessss\"); if ( i \u003e= result ) break; *(_BYTE *)(i + a1) ^= aAnextremelycom[i]; } return result; } To get our input, just simply XOR anextremelycomplicatedkeythatisdefinitelyuselessss together with 2\u0026 =$!-( \u003c*+*( ?!\u0026$$6,. )' $19 , #9=!1 \u003c*=6 \u003c6;66#. from malduck import * s1 = b'2\u0026 =$!-( \u003c*+*( ?!\u0026$$6,. )\\' $19 , #9=!1 \u003c*=6 \u003c6;66#' s2 = b'anextremelycomplicatedkeythatisdefinitelyuselessss' print(xor(s1, s2)) # b'SHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEP' SHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEPSHEEP will be our input for the last check. Put everything altogether, we should get our precious flag. Flag is: actf{g00dnight_c7822fb3af92b949} ","date":"2023-04-27","objectID":"/angstrom2023-rev/:3:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"Bananas Challenge Information Given file: Get it here! Description: A friend sent this to me. Can you help me find out what they want? Remote: nc challs.actf.co 31403 Points: 100 For this challenge, we are given an Erlang BEAM file to work with. This time, I googled and got this tool to decompile the BEAM file. After having decompiled the BEAM file, we should obtain a file named Elixir.Bananas.erl. -file(\"lib/bananas.ex\", 1). -module('Elixir.Bananas'). -compile([no_auto_import]). -export(['__info__'/1,main/0,main/1]). -spec '__info__'(attributes | compile | functions | macros | md5 | exports_md5 | module | deprecated) -\u003e any(). '__info__'(module) -\u003e 'Elixir.Bananas'; '__info__'(functions) -\u003e [{main, 0}, {main, 1}]; '__info__'(macros) -\u003e []; '__info__'(exports_md5) -\u003e \u003c\u003c\"TÀ}ÏÚ|º6þ\\020Í\\f\\035\\005\\222\\203\"\u003e\u003e; '__info__'(Key = attributes) -\u003e erlang:get_module_info('Elixir.Bananas', Key); '__info__'(Key = compile) -\u003e erlang:get_module_info('Elixir.Bananas', Key); '__info__'(Key = md5) -\u003e erlang:get_module_info('Elixir.Bananas', Key); '__info__'(deprecated) -\u003e []. check([_num@1, \u003c\u003c\"bananas\"\u003e\u003e]) -\u003e (_num@1 + 5) * 9 - 1 == 971; check(__asdf@1) -\u003e false. convert_input(_string@1) -\u003e to_integer('Elixir.String':split('Elixir.String':trim(_string@1))). main() -\u003e main([]). main(_args@1) -\u003e print_flag(check(convert_input('Elixir.IO':gets(\u003c\u003c\"How many bananas\" \" do I have?\\n\"\u003e\u003e)))). print_flag(false) -\u003e 'Elixir.IO':puts(\u003c\u003c\"Nope\"\u003e\u003e); print_flag(true) -\u003e 'Elixir.IO':puts('Elixir.File':'read!'(\u003c\u003c\"flag.txt\"\u003e\u003e)). to_integer([_num@1, _string@1]) -\u003e [binary_to_integer(_num@1), _string@1]; to_integer(_list@1) -\u003e _list@1. Although it looks complicated at first, but turns out the algorithm is easy to understand. About the intended algorithm flow The algorithm here is very simple, it takes our input as a string, splits it into several “words”, then it checks whether: Our input has only two words. First word (after converted to int) should satisfy this equation: (x + 5) * 9 - 1 == 971. Second word should be bananas. It is very easy to solve the challenge from this point, and our input should be 103 bananas according to the above rules. Flag is: actf{baaaaannnnananananas_yum} ","date":"2023-04-27","objectID":"/angstrom2023-rev/:4:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"Word Search Challenge Information Given file: Get it here! Description: I decided to put a few puzzles in the kids’ menu for the new AngstromCTF restaurant, but nobody has been able to solve it. Maybe you could take a crack at it. Points: 110 We are given a binary and a PDF file. The PDF file contains our needed string for solving the challenge. For the binary, we will have to use the latest IDA version to get the decompiled function (I tried using both IDA 7.6 and IDA 8.2, and only IDA 8.2 worked for me). __int64 __fastcall sub_1129(char *input_1, _BYTE *input_2) { char *v2; // rax char *v4; // rax char v5; // al char *v6; // rax char *v7; // rax _BYTE *v8; // rax _BYTE *v9; // rax _BYTE *v10; // rax _BYTE *v11; // [rsp+0h] [rbp-30h] char v13; // [rsp+16h] [rbp-1Ah] char v14; // [rsp+1Bh] [rbp-15h] int v15; // [rsp+1Ch] [rbp-14h] int v16; // [rsp+20h] [rbp-10h] int v17; // [rsp+24h] [rbp-Ch] v11 = input_2; while ( 1 ) { while ( 1 ) { // here while ( 1 ) { LABEL_2: v2 = input_1++; v13 = *v2; if ( *v2 == ')' || v13 == ']' || !v13 ) return v11 - input_2; if ( v13 != '(' \u0026\u0026 v13 != '[' ) break; if ( v13 == '(' ) { v4 = input_1++; v5 = *v4; } else { v5 = 95; } v14 = v5; qword_4040[v5] = input_1; while ( (*input_1 != ')' || v5 != input_1[1]) \u0026\u0026 *input_1 != ']' ) ++input_1; input_1 += 2; if ( v13 == '[' ) { while ( 1 ) { v17 = sub_1129((char *)qword_4040[v14], v11); if ( v17 \u003c 0 ) break; v11 += v17; } --input_1; } } if ( v13 != '\\'' ) break; v6 = input_1++; if ( (unsigned int)sub_1129((char *)qword_4040[*v6], v11) != -1 ) return 0xFFFFFFFFLL; } if ( v13 == '*' ) break; if ( v13 == ' ' ) { v8 = v11++; if ( !*v8 ) return 0xFFFFFFFFLL; } else if ( v13 == '?' ) { v9 = v11++; v15 = 0; while ( *input_1 != '?' ) { if ( *v9 == *input_1 ) v15 = 1; ++input_1; } ++input_1; if ( !v15 ) return 0xFFFFFFFFLL; } else if ( v13 != '.' ) { v10 = v11++; if ( *v10 != v13 ) return 0xFFFFFFFFLL; } } --input_1; while ( *input_1 == '*' ) { v7 = input_1 + 1; input_1 += 2; v16 = sub_1129((char *)qword_4040[*v7], v11); if ( v16 \u003e= 0 ) { v11 += v16; while ( *input_1 == '*' ) input_1 += 2; goto LABEL_2; } } return 0xFFFFFFFFLL; } After a relatively short time of analyzing the source, I came up with some conclusions. Conclusions The string given in the PDF file doesn’t contain any of these: [].*. Therefore, we can skip the correspondence parts in the source. For the substring between (...): The program sets the value of qword_4040[i] (with i being the character following the closing bracket) to that substring. For example: If we have (ab)c, the program will set qword_4040[c] = \"ab\". For the space: Don’t mind about it, kinda useless. For the apostrophe: Filter out qword_4040[i] (with i being the character following that apostrophe). Suppose we have something like (ab)c'c, then the program will filter out a and b. For the substring between ?...?: The program uses applied filter (as of the above clarification) to omit out some characters, and take the last character remaining. With that being considered, I wrote everything on a piece of paper (no script sadly) to get the flag from the hint provided in the PDF file (also with some reasonable guesses, too). Flag is: actf{both_irregular_and_inexpressive} Appendix After having solved the challenge, I did try to write a Python script. However, I failed to generate the flag using Python, maybe because the program has some additional constraints that I did not read carefully back then. But who cares, I got the flag anyway. ","date":"2023-04-27","objectID":"/angstrom2023-rev/:5:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"moon Challenge Information Given file: Get it here! Description: To the moon! The correct sequence of inputs is the flag in ASCII. Points: 130 We are once again given a 64-bit ELF file to work with. I decompiled it using IDA and after several hours into the source, I got to understand the general algorithm of the source. Algorithm Suppose that our input is represented by an array named arr. The input should have length of 1293. Each character of the input is assigned to a function, for example arr[i] is associated with func_i. Each function modifies 1293 variables (in the same order). Each variable will be checked with a hard-coded array, named needed. In conclusion, the problem is very basic. Just solve a system of 1293 equations, with 1293 variables and we are good to go. Having the algorithm in mind, it is time to write a Python script to solve it. from pwn import * e = ELF('./moon',checksec=False) needed = [] for i in range(1293): needed.append(int.from_bytes(e.read(e.sym['needed']+i*8, 8),'little')) Here, I dumped out needed - contains our right hand side for the system of equations. needed = [63393110, 58886046, 67388269, 63461910, 67974569, 60993599, 67115864, 65470744, ..., 60800092, 65494190, 67202755, 63501212, 65078012, 67079286, 59084245, 65591500] eq = [] base = 0x23ab900 check = [] for j in range(1293): if j != 1292: func = e.disasm(e.sym[f'func{j}'], e.sym[f'func{j+1}']-e.sym[f'func{j}']) else: func = e.disasm(e.sym['func1292'], e.sym['main']-e.sym['func1292']) ins = func.split('\\n') eq = [] i = 3 while i \u003c len(ins): if 'mov' in ins[i] and 'add rax,' in ins[i+1] and 'mov' in ins[i+2]: # print(ins[i+1]) num = int(ins[i+1].split(',')[1],16) eq.append(num) i = i + 3 elif 'mov' in ins[i] and 'sub rax,' in ins[i+1] and 'mov' in ins[i+2]: num = 0xffffffffffffffff - int(ins[i+1].split(',')[1], 16) + 1 eq.append(num) i = i + 3 elif 'mov' in ins[i] and 'mov' in ins[i+1]: eq.append(0) i = i + 2 else: i = i + 1 check.append(eq) For this part, I dumped out all coefficients of all equations. check = [[546, 25, 519, 123, 670, 104, 374, 208, ..., 183, 495, 82, 546, 770, 173, 68, 473]] from sage.all import * mat = Matrix(check) mat = mat.T needed = vector(needed) print(mat.solve_right(needed)) Put everything together, and using SageMath , we get the input needed. (74, 65, 78, 69, 32, 69, 89, 82, ..., 101, 56, 57, 54, 99, 57, 50, 125) Convert these into ASCII characters, we get the following (which turns out to also contain the flag): JANE EYRE AN AUTOBIOGRAPHY by Charlotte Brontë _ILLUSTRATED BY F. H. TOWNSEND_ London SERVICE \u0026 PATON 5 HENRIETTA STREET 1897 _The Illustrations_ _in this Volume are the copyright of_ SERVICE \u0026 PATON, _London_ TO W. M. THACKERAY, ESQ., This Work IS RESPECTFULLY INSCRIBED BY THE AUTHOR PREFACE A preface to the first edition of “Jane Eyre” being unnecessary, I gave none: this second edition demands a few words both of acknowledgment and miscellaneous remark. My thanks are due in three quarters. To the Public, for the indulgent ear it has inclined to a plain tale with few pretensions. To the Press, for the fair field its honest suffrage has opened to an obscure aspirant. To my Publishers, for the aid their tact, their energy, their practical sense and frank liberality have afforded an unknown and unrecommended Author. The Press and the Public are but vague personifications for me, and I must thank them in vague terms; but my Publishers are definite: so are certain generous critics who have encouraged me as only large-hearted and high-minded men know how to encourage a struggling stranger; to them, _i.e._, to my Publishers and the select Reviewers, I say cordially, Gentlemen, I thank you from my heart. actf{3verything_is_just_linear_algebr4_33e431e52e896c92} Flag is: actf{3verything_is_just_linear_algebr4_33e431e52e896c92} Appendix I tried using z3 to solve the input as a BitVec, but gained no success. Only after one of my Crypto teammate told me to use SageMath and some Linear Algebra (I learned the s","date":"2023-04-27","objectID":"/angstrom2023-rev/:6:0","tags":["RE","ångstromCTF","english"],"title":"ångstromCTF 2023 - Reverse Engineering Writeups","uri":"/angstrom2023-rev/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition.","date":"2023-03-24","objectID":"/htb2023/","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Short, descriptive write-ups for challenges I did from the competition. For other challenges/categories, check out my other blogs and our team’s blogs on BKISC Blog ","date":"2023-03-24","objectID":"/htb2023/:0:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Author notes Our team, BKISC finished at top 29 of this year Cyber Apocalypse 2023 - The Cursed Mission, solved 60/74 challenges, got 18175 points in total. Personally, I really enjoy playing in the competition, and I’m looking forward to other HTB CTFs in the future. For some challenges like Somewhat Linear or Analogue Signal Processing, since I collaborated with some other players from my team, the write-ups will be on our team’s blog, BKISC Blog . ","date":"2023-03-24","objectID":"/htb2023/:1:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Shattered Tablet Challenge Information Given file: Get it here! Description: Deep in an ancient tomb, you’ve discovered a stone tablet with secret information on the locations of other relics. However, while dodging a poison dart, it slipped from your hands and shattered into hundreds of pieces. Can you reassemble it and read the clues? Category: Reverse Engineering Difficulty: Very Easy Reverse Engineering category greets us with a binary. I used IDA Pro to decompile the binary. In the main function, the input is being checked through an if clause. I used angr to get the input (you can refer to this and this, too to get the hang of angr). Here is the Python script. import angr p = angr.Project('E:/Downloads/tablet') simgr = p.factory.simulation_manager(p.factory.entry_state()) simgr.explore(find=0x401359, avoid=0x401367) for i in range(3): print(simgr.found[0].posix.dumps(i)) We have to find the address of puts(\"Yes! That's right!\"); and avoid the address of puts(\"No... not that\");. Also, we have to increase each of the address by 0x400000 due to the fact that this binary is PIE-enabled . Flag is: HTB{br0k3n_4p4rt,n3ver_t0_b3_r3p41r3d} ","date":"2023-03-24","objectID":"/htb2023/:2:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Needle in a Haystack Challenge Information Given file: Get it here! Description: You’ve obtained an ancient alien Datasphere, containing categorized and sorted recordings of every word in the forgotten intergalactic common language. Hidden within it is the password to a tomb, but the sphere has been worn with age and the search function no longer works, only playing random recordings. You don’t have time to search through every recording - can you crack it open and extract the answer? Category: Reverse Engineering Difficulty: Very Easy We are given an another binary. Again, load the binary using IDA Pro . This time, the main algorithm of the binary is to print out a random element from the given list, and guess what, the flag is also there! Flag is: HTB{d1v1ng_1nt0_th3_d4tab4nk5} ","date":"2023-03-24","objectID":"/htb2023/:3:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"She Shells C Shells Challenge Information Given file: Get it here! Description: You’ve arrived in the Galactic Archive, sure that a critical clue is hidden here. You wait anxiously for a terminal to boot up, hiding in the shadows from the guards hunting for you. Unfortunately, it looks like you’ll need a password to get what you need without setting off the alarms… Category: Reverse Engineering Difficulty: Very Easy We get another binary, and it’s time to use IDA Pro to decompile it. Load the binary, we notice the function func_flag. Let’s check that out! fgets(s, 256, stdin); for ( i = 0; i \u003c= 0x4C; ++i ) s[i] ^= m1[i]; if ( memcmp(s, \u0026t, 0x4DuLL) ) return 0xFFFFFFFFLL; for ( j = 0; j \u003c= 0x4C; ++j ) s[j] ^= m2[j]; printf(\"Flag: %s\\n\", s); return 0LL; This is the main part of the function. Our input string s will be used to XOR with two lists, m1 and m2. We can use export data in IDA to dump out the contents of m1 and m2, as shown below (do the same for m2). We also know that after the first XOR, s needs to be equal to t (which we can get from the memory, too). Then we can reverse XOR to find s, and the algorithm looks like this. t[i] ^ m1[i] = s[i % 8] Since after the check, we continue to XOR m2 with the modified s (which should be equal to t after the memcmp), we get the algorithm to print out our flag. t[i] ^ m2[i] = flag[i] We can use this Python script to get the flag. m2 = [ 0x64, 0x1E, 0xF5, 0xE2, 0xC0, 0x97, 0x44, 0x1B, 0xF8, 0x5F, 0xF9, 0xBE, 0x18, 0x5D, 0x48, 0x8E, 0x91, 0xE4, 0xF6, 0xF1, 0x5C, 0x8D, 0x26, 0x9E, 0x2B, 0xA1, 0x02, 0xF7, 0xC6, 0xF7, 0xE4, 0xB3, 0x98, 0xFE, 0x57, 0xED, 0x4A, 0x4B, 0xD1, 0xF6, 0xA1, 0xEB, 0x09, 0xC6, 0x99, 0xF2, 0x58, 0xFA, 0xCB, 0x6F, 0x6F, 0x5E, 0x1F, 0xBE, 0x2B, 0x13, 0x8E, 0xA5, 0xA9, 0x99, 0x93, 0xAB, 0x8F, 0x70, 0x1C, 0xC0, 0xC4, 0x3E, 0xA6, 0xFE, 0x93, 0x35, 0x90, 0xC3, 0xC9, 0x10, 0xE9] t = [0x2C,0x4A,0x0B7,0x99,0x0A3,0x0E5,0x70,0x78,0x93,0x6E,0x97,0x0D9,0x47,0x6D,0x38,0x0BD,0x0FF,0x0BB,0x85,0x99,0x6F,0xE1,0x4A,0x0AB,0x74,0x0C3,0x7B,0x0A8,0x0B2,0x9F,0x0D7,0x0EC,0x0EB,0x0CD,0x63,0x0B2,0x39,0x23,0x0E1,0x84,0x92,0x96,0x09,0x0C6,0x99,0x0F2,0x58,0x0FA,0x0CB,0x6F,0x6F,0x5E,0x1F,0x0BE,0x2B,0x13,0x8E,0x0A5,0x0A9,0x99,0x93,0x0AB,0x8F,0x70,0x1C,0x0C0,0x0C4,0x3E,0x0A6,0x0FE,0x93,0x35,0x90,0x0C3,0x0C9,0x10,0x0E9] for i in range(len(t)): print(end=chr(t[i] ^ m2[i])) Flag is: HTB{cr4ck1ng_0p3n_sh3ll5_by_th3_s34_sh0r3} ","date":"2023-03-24","objectID":"/htb2023/:4:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Hunting License Challenge Information Given file: Get it here! Description: STOP! Adventurer, have you got an up to date relic hunting license? If you don’t, you’ll need to take the exam again before you’ll be allowed passage into the spacelanes! Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Reverse Engineering Difficulty: Easy We are given a binary file, together with a netcat server. By analyzing the binary file using file , we can answer some first questions. For the next question, we can use ldd license command to get some infos about libraries of the binary. For the upcoming question, I used gdb together with its info function command to get the address of the main function. Using IDA Pro , we can answer some more questions correctly. There will be 3 passwords for us to find, the first one is too obvious, the second one is reversed, and the last one is generated using XOR with the key 19. Here is the script for the last password. data = [0x47,0x7B,0x7A,0x61,0x77,0x52,0x7D,0x77,0x55,0x7A,0x7D,0x72,0x7F,0x32,0x32,0x32] key = 19 print(\"\".join(chr(i ^ key) for i in data)) Flag is: HTB{l1c3ns3_4cquir3d-hunt1ng_t1m3!} ","date":"2023-03-24","objectID":"/htb2023/:5:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Cave System Challenge Information Given file: Get it here! Description: Deep inside a cave system, 500 feet below the surface, you find yourself stranded with supplies running low. Ahead of you sprawls a network of tunnels, branching off and looping back on themselves. You don’t have time to explore them all - you’ll need to program your cave-crawling robot to find the way out… Category: Reverse Engineering Difficulty: Easy We are given a binary once again. Using IDA Pro , for this type of challenge, we should consider using angr or z3 solver . Here I choose to use angr . Here is the Python script. import angr p = angr.Project('E:/Downloads/cave') simgr = p.factory.simulation_manager(p.factory.entry_state()) simgr.explore(find=0x401ABA, avoid=0x401AC8) for i in range(3): print(simgr.found[0].posix.dumps(i)) We have to find the address of puts(\"Freedom at last!\"); and avoid the address of puts(\"Lost in the darkness, you'll wander for eternity...\");. Also, we have to increase each of the address by 0x400000 due to the fact that this binary is PIE-enabled . Flag is: HTB{H0p3_u_d1dn’t_g3t_th15_by_h4nd,1t5_4_pr3tty_l0ng_fl4g!!!} ","date":"2023-03-24","objectID":"/htb2023/:6:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Alien Saboteur Challenge Information Given file: Get it here! Description: You finally manage to make it into the main computer of the vessel, it’s time to get this over with. You try to shutdown the vessel, however a couple of access codes unknown to you are needed. You try to figure them out, but the computer start speaking some weird language, it seems like gibberish… Category: Reverse Engineering Difficulty: Medium We get a binary with a text file with no format. Analyze the binary using IDA Pro , from the function vm_create, the text file is contained in *(v3 + 18) and being executed like a normal binary. Each instructions appear to be at every 6th index from 0. From that, I wrote an interpreter for the text file (that runs through the binary). from malduck import xor ls = ['vm_add', 'vm_addi','vm_sub','vm_subi','vm_mul','vm_muli', 'vm_div', 'vm_cmp','vm_jmp','vm_inv', 'vm_push', 'vm_pop','vm_mov','vm_nop','vm_exit', 'vm_print', 'vm_putc','vm_je','vm_jne','vm_jle', 'vm_jge', 'vm_xor','vm_store', 'vm_load','vm_input'] def disass(code): i = 0 while i \u003c len(code): try: op = code[i] opr = ls[op] if opr == 'vm_add': print(\"{:03d}: ADD [{}] \u003c- [{}] + [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_addi': print(\"{:03d}: ADDI [{}] \u003c- [{}] + {}\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_sub': print(\"{:03d}: SUB [{}] \u003c- [{}] - [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_subi': print(\"{:03d}: SUBI [{}] \u003c- [{}] - {}\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_mul': print(\"{:03d}: MUL [{}] \u003c- [{}] * [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_muli': print(\"{:03d}: MULI [{}] \u003c- [{}] * {}\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_div': print(\"{:03d}: DIV [{}] \u003c- [{}] / [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_cmp': print(\"{:03d}: CMP flag \u003c- [{}] == [{}]\".format(i, ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_jmp': print(\"{:03d}: JMP pc \u003c- pc + [{}]\".format(i, chr(ls1[i + 2]))) i += 6 elif opr == 'vm_inv': print(\"{:03d}: INV [31] \u003c- syscall({}, {})\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_push': print(\"{:03d}: PUSH [{}]\".format(i, ls1[i + 1])) i += 6 elif opr == 'vm_pop': print(\"{:03d}: POP [{}]\".format(i, ls1[i + 1])) i += 6 elif opr == 'vm_mov': print(\"{:03d}: MOV [{}] \u003c- {}\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_nop': print(\"{:03d}: NOP\".format(i)) i += 6 elif opr == 'vm_exit': print(\"{:03d}: EXIT\".format(i)) i += 6 elif opr == 'vm_print': print(\"{:03d}: PRINT [{}]\".format(i, ls1[i + 1])) i += 6 elif opr == 'vm_putc': print(\"{:03d}: PUTC {}\".format(i, ascii(chr(ls1[i + 1])))) i += 6 elif opr == 'vm_je': print(\"{:03d}: JE pc \u003c- {} if [{}] == [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_jne': print(\"{:03d}: JNE pc \u003c- {} if [{}] != [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_jle': print(\"{:03d}: JLE pc \u003c- {} if [{}] \u003c= [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_jge': print(\"{:03d}: JGE pc \u003c- {} if [{}] \u003e= [{}]\".format(i, ls1[i + 3]*6, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_xor': print(\"{:03d}: XOR [{}] \u003c- [{}] ^ [{}]\".format(i, ls1[i + 1], ls1[i + 2], ls1[i + 3])) i += 6 elif opr == 'vm_store': print(\"{:03d}: STORE MEM[[{}]] \u003c- [{}]\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_load': print(\"{:03d}: LOAD [{}] \u003c- MEM[[{}]]\".format(i, ls1[i + 1], ls1[i + 2])) i += 6 elif opr == 'vm_input': print(\"{:03d}: INPUT [{}]\".format(i, ls1[i + 1])) i += 6 else: print(\"{:03d}: UNKNOWN\".format(i)) except: print(\"{:03d}: UNKNOWN {}\".format(i, op)) break with open('./bin','rb') as f: f = f.read() ls1 = [] ls2 = [] for i in f[3:]: ls1.append(i) for i in range(714, 714 + 220*6): ls1[i] = ls1[i] ^ 69 disass(ls1) Which gives the below output. 000: PUTC '[' 006: PUTC 'M' 012: PUTC 'a' 018","date":"2023-03-24","objectID":"/htb2023/:7:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Ancient Encodings Challenge Information Given file: Get it here! Description: Your initialization sequence requires loading various programs to gain the necessary knowledge and skills for your journey. Your first task is to learn the ancient encodings used by the aliens in their communication. Category: Crypto Difficulty: Very Easy We are given a Python script and a text file. Analyze the script, we get to know how the string is being encoded, which is Base 64 encode \u003e Conversion to long from bytes \u003e Hex. To get the original string, we simply reverse the process, using CyberChef with the hex given in the text file. Flag is: HTB{1n_y0ur_j0urn3y_y0u_wi1l_se3_th15_enc0d1ngs_ev3rywher3} ","date":"2023-03-24","objectID":"/htb2023/:8:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Small StEps Challenge Information Given file: Get it here! Description: As you continue your journey, you must learn about the encryption method the aliens used to secure their communication from eavesdroppers. The engineering team has designed a challenge that emulates the exact parameters of the aliens’ encryption system, complete with instructions and a code snippet to connect to a mock alien server. Your task is to break it. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Crypto Difficulty: Very Easy We are given two Python script. The server.py is to setup a server for RSA encryption. It will output n, e, ct upon connecting to the netcat server/run the Python script locally. Since e is always 3, we can use Low public exponent RSA attack to recover the initial message. In general, we only have to calculate cube root of ciphertext to get the plaintext. Below is the implementation of the attack in Python. from Crypto.Util.number import long_to_bytes import gmpy2 n = 884883504927573976507811885368533220992278181011115684591381528075201937106582650631361008463165895850991665645858432026935373136174833729634068491453157 e = 3 ct = 70407336670535933819674104208890254240063781538460394662998902860952366439176467447947737680952277637330523818962104685553250402512989897886053 pt = gmpy2.iroot(ct, 3)[0] # Get cube root of ct print(long_to_bytes(pt)) Flag is: HTB{5ma1l_E-xp0n3nt} ","date":"2023-03-24","objectID":"/htb2023/:9:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Trapped Source Challenge Information Description: Intergalactic Ministry of Spies tested Pandora’s movement and intelligence abilities. She found herself locked in a room with no apparent means of escape. Her task was to unlock the door and make her way out. Can you help her in opening the door? Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Web Exploitation Difficulty: Very Easy We are given a website that looks like it requires us to input the right password on a locker to process. View page source to see if anything is given, and we can see the correct pin is 8291. Input the correct pin and we get the flag for the challenge. Flag is: HTB{V13w_50urc3_c4n_b3_u53ful!!!} ","date":"2023-03-24","objectID":"/htb2023/:10:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Drobots Challenge Information Given file: Get it here! Description: Pandora’s latest mission as part of her reconnaissance training is to infiltrate the Drobots firm that was suspected of engaging in illegal activities. Can you help pandora with this task? Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Web Exploitation Difficulty: Very Easy We are given a website and a zip file containing the website’s source. After a quick analyze on the source, I get to understand that either we have to use SQL Injection or use a specific parameter to get to the next page. Input admin for the username and \" OR 1 = 1 -- - for the password, or add /home to the URL will grant you access to the next page, which turns out to also contains the flag. Flag is: HTB{p4r4m3t3r1z4t10n_1s_1mp0rt4nt!!!} ","date":"2023-03-24","objectID":"/htb2023/:11:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Initialise Connection Challenge Information Description: In order to proceed, we need to start with the basics. Start an instance, connect to it via $ nc e.g. nc 127.0.0.1 1337 and send “1” to get the flag. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Binary Exploitation/Pwnable Difficulty: Very Easy Just a sanity check challenge, do the same thing that is being stated in the description will grant you the flag. Flag is: HTB{g3t_r34dy_f0r_s0m3_pwn} ","date":"2023-03-24","objectID":"/htb2023/:12:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Questionnaire Challenge Information Given file: Get it here! Description: It’s time to learn some things about binaries and basic c. Connect to a remote server and answer some questions to get the flag. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Binary Exploitation/Pwnable Difficulty: Very Easy We are given a binary, a C file and a netcat server to answer some questions. From the netcat, we are given some informations about the binary that we will going to work with. When compiling C/C++ source code in Linux, an ELF (Executable and Linkable Format) file is created. The flags added when compiling can affect the binary in various ways, like the protections. Another thing affected can be the architecture and the way it's linked. If the system in which the challenge is compiled is x86_64 and no flag is specified, the ELF would be x86-64 / 64-bit. If it's compiled with a flag to indicate the system, it can be x86 / 32-bit binary. To reduce its size and make debugging more difficult, the binary can be stripped or not stripped. Dynamic linking: A pointer to the linked file is included in the executable, and the file contents are not included at link time. These files are used when the program is run. Static linking: The code for all the routines called by your program becomes part of the executable file. Stripped: The binary does not contain debugging information. Not Stripped: The binary contains debugging information. The most common protections in a binary are: Canary: A random value that is generated, put on the stack, and checked before that function is left again. If the canary value is not correct-has been changed or overwritten, the application will immediately stop. NX: Stands for non-executable segments, meaning we cannot write and execute code on the stack. PIE: Stands for Position Independent Executable, which randomizes the base address of the binary as it tells the loader which virtual address it should use. RelRO: Stands for Relocation Read-Only. The headers of the binary are marked as read-only. Run the 'file' command in the terminal and 'checksec' inside the debugger. The output of 'file' command: ✗ file test test: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=5a83587fbda6ad7b1aeee2d59f027a882bf2a429, for GNU/Linux 3.2.0, not stripped. The output of 'checksec' command: gef➤ checksec Canary : ✘ NX : ✓ PIE : ✘ Fortify : ✘ RelRO : Partial We are able to answer some first questions using these informations. After answering these questions correctly, we are provided with more informations about the binary. Great job so far! Now it's time to see some C code and a binary file. In the pwn_questionnaire.zip there are two files: 1. test.c 2. test The 'test.c' is the source code and 'test' is the output binary. Let's start by analyzing the code. First of all, let's focus on the '#include \u003cstdio.h\u003e' line. It includes the 'stdio.h' header file to use some of the standard functions like 'printf()'. The same principle applies for the '#include \u003cstdlib.h\u003e' line, for other functions like 'system()'. Now, let's take a closer look at: void main(){ vuln(); } By default, a binary file starts executing from the 'main()' function. In this case, 'main()' only calls another function, 'vuln()'. The function 'vuln()' has 3 lines. void vuln(){ char buffer[0x20] = {0}; fprintf(stdout, \"\\nEnter payload here: \"); fgets(buffer, 0x100, stdin); } The first line declares a 0x20-byte buffer of characters and fills it with zeros. The second line calls 'fprintf()' to print a message to stdout. Finally, the third line calls 'fgets()' to read 0x100 bytes from stdin and store them to the aformentioned buffer. Then, there is a custom 'gg()' function which calls the standard 'system()' function to print the flag. This function is never called by default. void gg(){ system(\"","date":"2023-03-24","objectID":"/htb2023/:13:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Getting Started Challenge Information Given file: Get it here! Description: Get ready for the last guided challenge and your first real exploit. It’s time to show your hacking skills. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Binary Exploitation/Pwnable Difficulty: Very Easy We are given a binary, a C file and a netcat server to work with. Same with the above challenge, netcat tells us to fill in some questions. Stack frame layout | . | \u003c- Higher addresses | . | |_____________| | | \u003c- 64 bytes | Return addr | |_____________| | | \u003c- 56 bytes | RBP | |_____________| | | \u003c- 48 bytes | target | |_____________| | | \u003c- 40 bytes | alignment | |_____________| | | \u003c- 32 bytes | Buffer[31] | |_____________| | . | | . | |_____________| | | | Buffer[0] | |_____________| \u003c- Lower addresses [Addr] | [Value] -------------------+------------------- 0x00007fff1ca33230 | 0x0000000000000000 \u003c- Start of buffer 0x00007fff1ca33238 | 0x0000000000000000 0x00007fff1ca33240 | 0x0000000000000000 0x00007fff1ca33248 | 0x0000000000000000 0x00007fff1ca33250 | 0x6969696969696969 \u003c- Dummy value for alignment 0x00007fff1ca33258 | 0x00000000deadbeef \u003c- Target to change 0x00007fff1ca33260 | 0x000055cf39fcf800 \u003c- Saved rbp 0x00007fff1ca33268 | 0x00007f62c548ac87 \u003c- Saved return address 0x00007fff1ca33270 | 0x0000000000000001 0x00007fff1ca33278 | 0x00007fff1ca33348 After we insert 4 \"A\"s, (the hex representation of A is 0x41), the stack layout like this: [Addr] | [Value] -------------------+------------------- 0x00007fff1ca33230 | 0x0000000041414141 \u003c- Start of buffer 0x00007fff1ca33238 | 0x0000000000000000 0x00007fff1ca33240 | 0x0000000000000000 0x00007fff1ca33248 | 0x0000000000000000 0x00007fff1ca33250 | 0x6969696969696969 \u003c- Dummy value for alignment 0x00007fff1ca33258 | 0x00000000deadbeef \u003c- Target to change 0x00007fff1ca33260 | 0x000055cf39fcf800 \u003c- Saved rbp 0x00007fff1ca33268 | 0x00007f62c548ac87 \u003c- Saved return address 0x00007fff1ca33270 | 0x0000000000000001 0x00007fff1ca33278 | 0x00007fff1ca33348 After we insert 4 \"B\"s, (the hex representation of B is 0x42), the stack layout looks like this: [Addr] | [Value] -------------------+------------------- 0x00007fff1ca33230 | 0x4242424241414141 \u003c- Start of buffer 0x00007fff1ca33238 | 0x0000000000000000 0x00007fff1ca33240 | 0x0000000000000000 0x00007fff1ca33248 | 0x0000000000000000 0x00007fff1ca33250 | 0x6969696969696969 \u003c- Dummy value for alignment 0x00007fff1ca33258 | 0x00000000deadbeef \u003c- Target to change 0x00007fff1ca33260 | 0x000055cf39fcf800 \u003c- Saved rbp 0x00007fff1ca33268 | 0x00007f62c548ac87 \u003c- Saved return address 0x00007fff1ca33270 | 0x0000000000000001 0x00007fff1ca33278 | 0x00007fff1ca33348 From the netcat, we are provided with these informations. We can answer the question by looking at the informations given, where we have to overwrite the alignment address and the target's 0xdeadbeef value. From the stack layout given above, we can see that to fully overwrite, we need at least 40 bytes input (assume that we use Linux terminal because there will be a \\x00 overwrite at the right of the target's 0xdeadbeef value) which will look like this. I don’t know why it prints out [-] You failed! though… Flag is: HTB{b0f_s33m5_3z_r1ght?} ","date":"2023-03-24","objectID":"/htb2023/:14:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Plaintext Tleasure Challenge Information Given file: Get it here! Description: Threat intelligence has found that the aliens operate through a command and control server hosted on their infrastructure. Pandora managed to penetrate their defenses and have access to their internal network. Because their server uses HTTP, Pandora captured the network traffic to steal the server’s administrator credentials. Open the provided file using Wireshark, and locate the username and password of the admin. Category: Forensics Difficulty: Very Easy We are given a network pcap file. Although we can solve this challenge using Wireshark , but to keep it simple for the very first challenge, we will use strings and grep to get the flag. Here we use strings to dump out strings from the pcap file, then use pipe (|) and grep to find for strings that match the flag format - HTB{. Flag is: HTB{th3s3_4l13ns_st1ll_us3_HTTP} ","date":"2023-03-24","objectID":"/htb2023/:15:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Alien Cradle Challenge Information Given file: Get it here! Description: In an attempt for the aliens to find more information about the relic, they launched an attack targeting Pandora’s close friends and partners that may know any secret information about it. During a recent incident believed to be operated by them, Pandora located a weird PowerShell script from the event logs, otherwise called PowerShell cradle. These scripts are usually used to download and execute the next stage of the attack. However, it seems obfuscated, and Pandora cannot understand it. Can you help her deobfuscate it? Category: Forensics Difficulty: Very Easy For this challenge, we are given a Powershell Script file. In the script, the flag is being concatenated using some Powershell magic lines of code. Flag is: HTB{p0w3rsh3ll_Cr4dl3s_c4n_g3t_th3_j0b_d0n3} ","date":"2023-03-24","objectID":"/htb2023/:16:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Extraterrestrial Persistence Challenge Information Given file: Get it here! Description: There is a rumor that aliens have developed a persistence mechanism that is impossible to detect. After investigating her recently compromised Linux server, Pandora found a possible sample of this mechanism. Can you analyze it and find out how they install their persistence? Category: Forensics Difficulty: Very Easy In this challenge, we are given a shell script to look for the flag. For the sake of understanding the flow of shell scripting, the script checks whether the username is Pandora and the hostname is linux_HQ. If the check is fulfilled, it starts the process to write the base64 decoded message into the file /usr/lib/systemd/system/service.service. The decoded message turned out to contain the flag for our challenge. Flag is: HTB{th3s3_4l13nS_4r3_s00000_b4s1c} ","date":"2023-03-24","objectID":"/htb2023/:17:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Relic Maps Challenge Information Given file: Get it here! Description: Pandora received an email with a link claiming to have information about the location of the relic and attached ancient city maps, but something seems off about it. Could it be rivals trying to send her off on a distraction? Or worse, could they be trying to hack her systems to get what she knows?Investigate the given attachment and figure out what’s going on and get the flag. The link is to http://relicmaps.htb:/relicmaps.one. The document is still live (relicmaps.htb should resolve to your docker instance). Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Forensics Difficulty: Medium From the link attached to this challenge, we get an Onenote file named relicmaps.one. Analyze the file, we get 2 suspicious links, which lead us to 2 different files, http://relicmaps.htb/uploads/soft/topsecret-maps.one and http://relicmaps.htb/get/DdAbds/window.bat . I did some analysis on the file topsecret-maps.one, and there are only some PNGs inside it. In the window.bat file, we are given a Powershell Script. You can run it directly, but I choose to deobfuscate using Python to understand its flow. dict = \"\"\" %eFlP%\"ualBOGvshk=ws\" %eFlP%\"PxzdwcSExs= /\" %eFlP%\"ndjtYQuanY=po\" %eFlP%\"cHFmSnCqnE=Wi\" %eFlP%\"CJnGNBkyYp=co\" %eFlP%\"jaXcJXQMrV=rS\" %eFlP%\"nwIWiBzpbz=:\\\" %eFlP%\"xprVJLooVF=Po\" %eFlP%\"tzMKflzfvX=0\\\" %eFlP%\"VCWZpprcdE=1.\" %eFlP%\"XzrrbwrpmM=\\v\" %eFlP%\"BFTOQBPCju=st\" %eFlP%\"WmUoySsDby=he\" %eFlP%\"tHJYExMHlP=rs\" %eFlP%\"JPfTcZlwxJ=do\" %eFlP%\"VxroDYJQKR=y \" %eFlP%\"UBndSzFkbH=py\" %eFlP%\"KXASGLJNCX=ll\" %eFlP%\"vlwWETKcZH=em\" %eFlP%\"OOOxFGwzUd=e\"\" %eFlP%\"NCtxqhhPqI=32\" %eFlP%\"GOPdPuwuLd=\\W\" %eFlP%\"XUpMhOyyHB=ex\" %eFlP%\"cIqyYRJWbQ=we\" %eFlP%\"kTEDvsZUvn=nd\" %eFlP%\"XBucLtReBQ=Sy\" %eFlP%\"JBRccySrUq=ow\" %eFlP%\"eNOycQnIZD=xe\" %eFlP%\"chXxviaBCr=we\" %eFlP%\"YcnfCLfyyS=in\" %eFlP%\"lYCdEGtlPA=.e\" %eFlP%\"pMrovuxjjq=he\" %eFlP%\"UrPeBlCopW=ll\" %eFlP%\"ujJtlzSIGW= C\" %eFlP%\"zhNAugCrcK=\"%~0.\" %eFlP%\"ZqjBENExAX=s\\\" %VhIy%\"dzPrbmmccE=cd\" %VhIy%\"xQseEVnPet= \"%~dp0\"\" %eUFw%\"wxzMwkmbmY=gDBN\" %eUFw%\"VavtsuhNIN=F'[-\" %eUFw%\"AHKCuBAkui=r = \" %eUFw%\"ARecVABHyu=uZOc\" %eUFw%\"AbZpTpKurz=6] -\" %eUFw%\"BaMYsIgnsM=$uZO\" %eUFw%\"JBUgbyTPxp=m(, \" %eUFw%\"vGOYQQYIpx=.-16\" %eUFw%\"yPzFwnsYdA= New\" %eUFw%\"zuIYfGJIhV=O.Me\" %eUFw%\"gbXeIdPSoj='[-1\" %eUFw%\"BqEMjgsfHM=]::(\" %eUFw%\"bivuMABwCB=Invo\" %eUFw%\"SJsEzuInUY=ile \" %eUFw%\"htJeDhbeDW=();$\" %eUFw%\"ZygfZJxAOd=acUA\" %eUFw%\"eDhTebXJLa=\"%~nx0.\" %eUFw%\"YlKbYsFYPy=in $\" %eUFw%\"jdKMRqipbM=e]::\" %eUFw%\"GVIREkvxRa=();$\" %eUFw%\"OckpqzbYcn=n ''\" %eUFw%\"UPfjubfNXt=Mr, \" %eUFw%\"AkaPyEXHFq=esMa\" %eUFw%\"LODxmGMGqq=flec\" %eUFw%\"hImzprlFyw=pose\" %eUFw%\"VZAbZqJHBk=1] -\" %eUFw%\"WYJXnBQBDj= [Sy\" %eUFw%\"rSVBNvbdPT=stem\" %eUFw%\"tVtxVGNpFB=vert\" %eUFw%\"tHHIjVCHeH=::De\" %eUFw%\"WvjMoIIiUn=);$b\" %eUFw%\"vmIEtsktnA=ypto\" %eUFw%\"AbMyvUGzSH=fore\" %eUFw%\"zDUDeXKPaV=..-1\" %eUFw%\"INPLAzQfUo== [S\" %eUFw%\"ArAxZuPIrp== $B\" %eUFw%\"nGqMpclaJV=ZOcm\" %eUFw%\"lfYSggLrsL=null\" %eUFw%\"eQPFkQsLmh=hy.A\" %eUFw%\"AyyrPvjwjr=;$mN\" %eUFw%\"rjhOhltPzI=Disp\" %eUFw%\"WojQSFImBz=17js\" %eUFw%\"SKEwAQBRlN=$Nlg\" %eUFw%\"KytxcYPZKt=YiLG\" %eUFw%\"RGlZIMTaRM=urit\" %eUFw%\"igJmqZApvQ=ss -\" %eUFw%\"dGSGnKbkQW=pose\" %eUFw%\"lSUnvlNyZI=tem.\" %eUFw%\"rddZbDFvhl=)))\" %eUFw%\"KHqiJghRbq=and \" %eUFw%\"WPGlloqWfh=ddin\" %eUFw%\"pLUeCEDcNj=]::C\" %eUFw%\"drymkVAnZW=);$B\" %eUFw%\"KdByPVjCnF=ring\" %eUFw%\"VnDoNvCbDL=orF'\" %eUFw%\"GapFScCcpe=ke($\" %eUFw%\"iVrCyJhMiJ=fc6t\" %eUFw%\"oMsMdPYmPd=ert]\" %eUFw%\"odWdfvJnBE=Lk =\" %eUFw%\"ekEoGMuERC=yste\" %eUFw%\"QMmDXFyyag=Syst\" %eUFw%\"cYinxarhDL=lit(\" %eUFw%\"bIgeRgvTeJ=ap.T\" %eUFw%\"acXjUrxrpX=raph\" %eUFw%\"SCbDgQuqTU=ay()\" %eUFw%\"YYKSCuCbgJ=New-\" %eUFw%\"YnGvhgYxvb=cm =\" %eUFw%\"vnHosfjdeN=;$Pt\" %eUFw%\"LIQYgFxctD=d;$B\" %eUFw%\"olHsTHINJO=[Env\" %eUFw%\"WQqetkePWs=NVPb\" %eUFw%\"AGOCIKFMEK=::('\" %eUFw%\"QbKdEZdxpx=uGcO\" %eUFw%\"RWcegafVtf=daeR\" %eUFw%\"ESpdErsKEO=pher\" %eUFw%\"kJjQuXIjOT=.Con\" %eUFw%\"dbDMRBPrxg=uGcO\" %eUFw%\"mBIWiJNHWZ=es","date":"2023-03-24","objectID":"/htb2023/:18:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Persistence Challenge Information Description: Thousands of years ago, sending a GET request to /flag would grant immense power and wisdom. Now it’s broken and usually returns random data, but keep trying, and you might get lucky… Legends say it works once every 1000 tries. Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Miscellaneous Difficulty: Very Easy We are given a website to work with. Initially, connection to the website would result in 404 Not Found. I then went to read the descriptions, and from it, I got to know that we should send at least 1000 GET requests to /flag to maybe get the flag. I used this below Python script to automate the task. import requests url = \"http://64.227.41.83:30380/flag\" for i in range(10000): response = requests.get(url) content = response.content if b'HTB{' in content: print(content) break After a short wait, we got the flag. Flag is: HTB{y0u_h4v3_p0w3rfuL_sCr1pt1ng_ab1lit13S!} ","date":"2023-03-24","objectID":"/htb2023/:19:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"Restricted Challenge Information Given file: Get it here! Description: You ’re still trying to collect information for your research on the alien relic. Scientists contained the memories of ancient egyptian mummies into small chips, where they could store and replay them at will. Many of these mummies were part of the battle against the aliens and you suspect their memories may reveal hints to the location of the relic and the underground vessels. You managed to get your hands on one of these chips but after you connected to it, any attempt to access its internal data proved futile. The software containing all these memories seems to be running on a restricted environment which limits your access. Can you find a way to escape the restricted environment ? Note: This challenge had a docker but it might be closed at the time you are reading this. All needed files will be given in the write-ups. Category: Miscellaneous Difficulty: Easy We are provided with a server and it’s source. From the source, we know that it is a SSH server. One thing particular about this server is that, if the username is restricted, we will not need to provide a password to authenticate, but the user will be in restricted shell mode. What is restricted shell? If Bash is started with the name rbash, or the –restricted or -r option is supplied at invocation, the shell becomes restricted. A restricted shell is used to set up an environment more controlled than the standard shell. A restricted shell behaves identically to bash with the exception that some commands are disallowed or not performed. For instances, changing directories with the cd builtin is prohibited in restricted shell. To cope with this, we can use a trick called SSH self loop-back, which means we initiate a SSH connection inside a SSH, since restricted shell doesn’t prevent us from using SSH commands. First, we connect to the SSH server using the username restricted. From the source, we also know that the exposed port is 1337. Then, we can use SSH self loop-back to have the permission to use cat, since we also know that flag.txt is changed to flag_* (with * represents some random bytes) and lies in plainsight. Flag is: HTB{r35tr1ct10n5_4r3_p0w3r1355} ","date":"2023-03-24","objectID":"/htb2023/:20:0","tags":["RE","pwn","web","crypto","forensics","misc","htb","english"],"title":"Cyber Apocalypse 2023: The Cursed Mission - Writeups","uri":"/htb2023/"},{"categories":["Writeups"],"content":"An in-depth writeup on ISITDTU CTF 2022 Finals - Slow","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"An in-depth writeup on ISITDTU CTF 2022 Finals - Slow. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:0:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Introduction Challenge Information Given binary: Get it here! Description: If you can make the program runs faster, you’ll get the flag! Category: Reverse Engineering ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:1:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Static Analysis The challenge provides us with a single binary, named slow.exe. By using IDA Pro or Ghidra or any other kinds of decompiler, we will get the decompiled code. Analyze the main function, we claim that the program initiates an array whose size is 45, then modifies it through some more functions, as shown below. int __cdecl main(int argc, const char **argv, const char **envp) { void *Block; // [esp+4h] [ebp-BCh] int v5[45]; // [esp+8h] [ebp-B8h] BYREF v5[0] = 10; v5[1] = -3; ... snip v5[43] = 14; v5[44] = 16; Block = (void *)sub_401AC0(v5, 38, 0); sub_4013B0(Block); sub_401B40(Block); return 0; } The function sub_401AC0(v5, 38, 0) allocates dynamic memory using malloc based on v5 then assigns it into variable Block. That variable is then being passed into function sub_4013B0(Block), which will produce our flag once we have fixed it. int __cdecl sub_4013B0(_DWORD *a1) { int result; // eax int v2; // eax int v3; // [esp+4h] [ebp-64h] ... snip int v37; // [esp+64h] [ebp-4h] int v38; // [esp+64h] [ebp-4h] while ( 1 ) { v6 = *(_DWORD *)(a1[1] + 4 * a1[3]++); result = v6 - 1; switch ( v6 ) { case 1: v22 = *(_DWORD *)(a1[2] + 4 * a1[4]--); v26 = *(_DWORD *)(a1[2] + 4 * a1[4]--); v2 = sub_401110(v26, v22); v16 = a1[4] + 1; a1[4] = v16; *(_DWORD *)(a1[2] + 4 * v16) = v2; break; case 2: ... snip case 4: ... snip case 5: ... snip case 6: ... snip case 7: ... snip case 8: ... snip case 9: ... snip case 10: ... snip case 11: ... snip case 12: ... snip case 13: ... snip case 14: v38 = *(_DWORD *)(a1[2] + 4 * a1[4]--); sub_401040(\"RESULT: %d\\n\", v38); sub_401260(v38); break; case 15: ... snip case 16: ... snip case 17: ... snip case 18: ... snip default: continue; } } } Why didn't I snip case 1 and case 14 in the above pseudocode? It is easy to observe that only these two cases involve calling other functions. To be more precise, if the program reaches case 1, the function sub_401110(v26, v22) will be called, and on the other hand, if the program reaches case 14, the function sub_401260(v38) will be called. We will talk more about these two functions in the next parts of this blog. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:2:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Reaching case 14 As stated earlier, the function sub_401260(v38) will be called if the program reaches case 14, which will be the last part of our code flow. int __cdecl sub_401260(char a1) { char v2[256]; // [esp+10h] [ebp-224h] BYREF char Buffer; // [esp+110h] [ebp-124h] BYREF _BYTE v4[3]; // [esp+111h] [ebp-123h] BYREF char v5[32]; // [esp+210h] [ebp-24h] BYREF qmemcpy(v5, \"Áõ\", 2); v5[2] = -77; v5[3] = 26; ... snip v5[28] = -66; v5[29] = 63; memset(v2, 0, sizeof(v2)); sub_401D50(\u0026Buffer, \"%d\", 55 * a1); sub_401160(v5, v2, 30, \u0026Buffer, \u0026v4[strlen(\u0026Buffer)] - v4); return sub_401040(\"flag is: %s\", (char)v2); } The function receives our modified variable Block, then uses it to produce our flag. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:3:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Reaching case 1 Here is where things get interesting. Take a look at the function sub_401110(v26, v22), we can conclude that this is why our program runs slowly. The fact that it makes our program sleeps plus it is possibly called many times throughout the process makes our executable runs without any output for a very long time. int __cdecl sub_401110(int a1, int a2) { int v3; // [esp+0h] [ebp-4h] v3 = sub_4010F0(0); Sleep(1000 * a1); Sleep(1000 * a2); return sub_4010F0(0) - v3; } About the intended algorithm flow The algorithm here is very simple, however this is author’s idea to let the program sleeps for a total of (a1 + a2) seconds each time this function is called. The intended result of this function is to return a1 + a2. We will have to patch the binary to get our flag. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:4:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Patch the binary So we know what makes our program runs slowly, it is time to fix that. Below is the decompiled assembly code of that part. mov ecx, [ebp+arg_0] mov edx, [ecx+10h] sub edx, 1 mov eax, [ebp+arg_0] mov [eax+10h], edx mov ecx, [ebp+var_10] push ecx mov edx, [ebp+var_C] push edx call sub_401110 add esp, 8 mov [ebp+var_58], eax mov eax, [ebp+arg_0] Instead of calling sub_401110, we should patch the program to directly calculates ecx + edx then assigns it into eax. We find out that the opcode of call sub_401110 is E8 77 FC FF FF. View instructions opcode in IDA Pro Using IDA Pro integrated settings, which can be found at Options \u003e Generals \u003e Number of Opcode bytes (non-graph) set to a large enough number, we can view each instruction’s opcode. With pwntools library, we also find out the opcode for add ecx, edx and move eax, ecx is 01 D1 and 89 C8 using this script written in Python below. from pwn import * context.arch = 'amd64' print(asm('add ecx, edx')) print(asm('mov eax, ecx')) It is now time to patch the binary. Use any hex editor of your choice to patch the binary, here I use IDA Pro’s integrated hex view to patch the binary. Our goal Change E8 77 FC FF FF to 01 D1 89 C8 90 using any hex editor of your choice (here 90 corresponds to the NOP instruction). ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:5:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":["Writeups"],"content":"Result After patching the binary, run it again to get our flag. fazect@LAPTOP-CQA118DI:/mnt/d/Downloads$ ./slow.exe RESULT: 75025 flag is: Pr4ct1c3_VMc0d3_w1th_F1b0n4cc1 Wrap the flag with ISITDTU{}, we have our flag for the challenge: ISITDTU{Pr4ct1c3_VMc0d3_w1th_F1b0n4cc1}. ","date":"2023-01-02","objectID":"/isitdtu2022finals-slow/:6:0","tags":["RE","isitdtu","english"],"title":"ISITDTU CTF 2022 Finals - Slow","uri":"/isitdtu2022finals-slow/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Some Background Informations I am FazeCT, a Reverser from team BKISC , HCMC University of Technology and international team thehackerscrew . I have been studying in Computer Science, HCMC University of Technology since October 2021. Started playing CTFs since July 2022, currently I am focusly learning in the Reverse Engineering (RE) field of CTF. Being an intern at Sky Mavis , I am also looking forward to learn more about Blockchain in the future. ","date":"0001-01-01","objectID":"/aboutme/:1:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Noticeable Achievements Qualified for ISITDTU CTF 2022 Finals in Da Nang, Vietnam. Qualified for Hacktheon Sejong Finals in Sejong, Korea. Honorable Mention in 2022 ACM-ICPC Asia HoChiMinh City Regional Contest ","date":"0001-01-01","objectID":"/aboutme/:2:0","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Contact Me You can contact me via Email , Twitter or Github . ","date":"0001-01-01","objectID":"/aboutme/:3:0","tags":null,"title":"About Me","uri":"/aboutme/"}]